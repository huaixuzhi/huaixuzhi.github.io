<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>纸上得来</title>
  
  <subtitle>酒盏酌来须满满，花枝看即落纷纷。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huaixuzhi.github.io/"/>
  <updated>2018-03-13T03:52:52.240Z</updated>
  <id>http://huaixuzhi.github.io/</id>
  
  <author>
    <name>keyoflov</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GO语言下划线的作用</title>
    <link href="http://huaixuzhi.github.io/2018/03/13/go-underline-description/"/>
    <id>http://huaixuzhi.github.io/2018/03/13/go-underline-description/</id>
    <published>2018-03-13T03:26:14.000Z</published>
    <updated>2018-03-13T03:52:52.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用于返回值"><a href="#用于返回值" class="headerlink" title="用于返回值"></a>用于返回值</h3><p>　　某个函数返回三个参数，但是我们只需要其中的两个，另外一个参数可以忽略，这样的话代码可以这样写：<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1, v2, _ := <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure></p><h3 id="用于变量（特别是接口断言）"><a href="#用于变量（特别是接口断言）" class="headerlink" title="用于变量（特别是接口断言）"></a>用于变量（特别是接口断言）</h3><p>　　1)例如我们定义了一个接口（interface）<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">Foo</span> interface&#123;</span><br><span class="line"><span class="type">Say</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　2)然后定义一个结构体（struct）<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span>  <span class="title">Dog</span></span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　3)然后我门希望在代码中判断Dog这个struct是否是实现了interface Foo<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">_</span> Foo = Dog()</span><br></pre></td></tr></table></figure></p><p>　　用作类型断言，如果Dog没有实现Foo，则会报编译错误。</p><h3 id="用于-import-package"><a href="#用于-import-package" class="headerlink" title="用于 import package"></a>用于 import package</h3><p>　　import 下划线（如：import _ hello/imp）的作用：当导入一个包时，该包下的文件里所有init()函数都会被执行，然而，有些时候我们并不需要把整个包都导入进来，仅仅是是希望它执行init()函数而已。这个时候就可以使用 import _ 引用该包。即使用”import _ 包路径”只是引用该包，仅仅是为了调用init()函数，所以无法通过包名来调用包中的其他函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> _ <span class="string">"hello/imp"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//imp.Print() //编译报错，说：undefined: imp</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      v1, v2, _ := function(...)
    
    </summary>
    
      <category term="GO语言" scheme="http://huaixuzhi.github.io/categories/GO%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="基础知识" scheme="http://huaixuzhi.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="GO语言" scheme="http://huaixuzhi.github.io/tags/GO%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>TCP单机连接数限制</title>
    <link href="http://huaixuzhi.github.io/2018/01/31/tcp-limit/"/>
    <id>http://huaixuzhi.github.io/2018/01/31/tcp-limit/</id>
    <published>2018-01-31T03:41:18.000Z</published>
    <updated>2018-03-07T06:10:37.670Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP连接建立和释放流程："><a href="#TCP连接建立和释放流程：" class="headerlink" title="TCP连接建立和释放流程："></a>TCP连接建立和释放流程：</h3><img src="/2018/01/31/tcp-limit/tcp.png"><h3 id="TCP短连接"><a href="#TCP短连接" class="headerlink" title="TCP短连接"></a>TCP短连接</h3><p>　　在建立连接后，一般只会在Client和Server之间传递一次读写操作，然后链接关闭。<br>　　短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段</p><h3 id="TCP长连接"><a href="#TCP长连接" class="headerlink" title="TCP长连接"></a>TCP长连接</h3><p>　　在建立连接，Client与Server完成一次读写后，它们之间的连接不会主动关闭，后续的读写操作会继续使用这个连接。</p><h3 id="TCP长连接keepalive机制"><a href="#TCP长连接keepalive机制" class="headerlink" title="TCP长连接keepalive机制"></a>TCP长连接keepalive机制</h3><p>　　默认的Keepalive超时需要2小时，探测次数为5次。开启Keepalive功能需要消耗额外的宽带和流量，尽管这微不足道，但在按流量计费的环境下增加了费用，另一方面，Keepalive设置不合理时可能会因为短暂的网络波动而断开健康的TCP连接。<br>　　<b>keepalive工作原理：</b><br>　　若在一个给定连接上，两小时之内无任何活动，服务器便向客户端发送一个探测段。</p><ul><li>客户端主机依旧活跃（up）运行，并且从服务器可到达。从客户端TCP的正常响应，服务器知道对方仍然活跃。服务器的TCP为接下来的两小时复位存活定时器，如果在这两个小时到期之前，连接上发生应用程序的通信，则定时器重新为往下的两小时复位，并且接着交换数据。</li><li>客户端已经崩溃，或者已经关闭（down），或者正在重启过程中。在这两种情况下，它的TCP都不会响应。服务器没有收到对其发出探测的响应，并且在75秒之后超时。服务器将总共发送10个这样的探测，每个探测75秒。如果没有收到一个响应，它就认为客户端主机已经关闭并终止连接。</li><li>客户端曾经崩溃，但已经重启。这种情况下，服务器将会收到对其存活探测的响应，但该响应是一个复位，从而引起服务器对连接的终止。</li><li>客户端主机活跃运行，但从服务器不可到达。这与状态2类似，因为TCP无法区别它们两个。它所能表明的仅是未收到对其探测的回复。</li></ul><p>　　服务器不必担心客户端主机被关闭然后重启的情况（这里指的是操作员执行的正常关闭，而不是主机的崩溃）。当系统被操作员关闭时，所有的应用程序进程（也就是客户端进程）都将被终止，客户端TCP会在连接上发送一个FIN。收到这个FIN后，服务器TCP向服务器进程报告一个文件结束，以允许服务器检测这种状态。<br>　　<font color="red">在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务</font></p><h3 id="TCP连接数的限制"><a href="#TCP连接数的限制" class="headerlink" title="TCP连接数的限制"></a>TCP连接数的限制</h3><p>　　TCP连接数主要受到三个方面的限制：文件描述符、TCP连接本身的数量、系统内存。</p><ul><li>每个TCP连接对应一个socket对象，每个socket对象本身占用一个文件描述符；</li><li>TCP四元组（源IP地址，源端口，目标IP地址，目标端口）标识一个TCP连接，对于两个TCP连接，四个参数里面必定有一个不同。对于服务器来说，一般来说，IP和本地端口固定，可以接受的连接数=2^32*65535；对于客户端来说，一般本地IP，远端IP，远端端口号都是固定的，因此可以支持的长连接数最多只有65535，所以，作为客户端的服务器比较容易出现端口耗尽的问题。<br><b>Linux系统对端口的限制，如下：</b><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@dcgcy-test50 <span class="keyword">workspace</span>]# cat /<span class="keyword">proc</span>/sys/net/ipv4/ip_local_port_range</span><br><span class="line"><span class="number">1024</span>    <span class="number">65000</span></span><br></pre></td></tr></table></figure></li></ul><p>　　这两个值分别代表最小值和最大值，小于1024的端口号一般是预留给系统使用的，这不是强制的，你一定要把最小值改成小于1024也是可以的。</p><ul><li>关于系统内存限制，主要包含两个方面，一个是TCP元数据大小：包含sock、inode、file等结构；二是TCP缓存占用空间，又包含系统缓存和用户缓存，其中系统缓存是系统调用read/write使用的缓存，用户缓存是我们代码中设计的缓存区。<br>　　高人测试：写两个程序，服务端只接收连接，客户端只发起连接，不读写数据，客户端和服务端分别部署在两个虚拟机上，当建立50w个连接时，服务端消耗2g内存，大概每个socket占用4kb，这个4kb是内核申请的空间，并不增加用户进程的内存。</li></ul><p><b>附：TCP/IP的四元组、五元组、七元组</b><br>四元组是：<br>　　源IP地址、目的IP地址、源端口、目的端口<br>五元组是:<br>　　源IP地址、目的IP地址、协议号、源端口、目的端口<br>七元组是:<br>　　源IP地址、目的IP地址、协议号、源端口、目的端口，服务类型以及接口索引</p><p>参考网址：<br><a href="http://th7.cn/system/lin/201709/228306.shtml" target="_blank" rel="noopener">http://th7.cn/system/lin/201709/228306.shtml</a></p>]]></content>
    
    <summary type="html">
    
      
    
    </summary>
    
      <category term="网络" scheme="http://huaixuzhi.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="基础知识" scheme="http://huaixuzhi.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="架构" scheme="http://huaixuzhi.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux打开文件句柄限制</title>
    <link href="http://huaixuzhi.github.io/2018/01/31/fd-limit/"/>
    <id>http://huaixuzhi.github.io/2018/01/31/fd-limit/</id>
    <published>2018-01-31T03:16:14.000Z</published>
    <updated>2018-03-13T03:51:36.438Z</updated>
    
    <content type="html"><![CDATA[<p>出现Socket/File: Can’t open so many files问题，任何*nux系统，限制数都可以由ulimit或setrlimit来设置。<br><a id="more"></a></p><h3 id="Linux系统中与文件描述符相关的参数："><a href="#Linux系统中与文件描述符相关的参数：" class="headerlink" title="Linux系统中与文件描述符相关的参数："></a>Linux系统中与文件描述符相关的参数：</h3><ul><li>soft/hard nofile<br>　　即ulimit -n查看到的值，”可以打开最大文件描述符的数量”，是对单一程序的限制，进程级别的。<br>　　ulimit限制分为软限制和硬限制，硬限制是实际限制，软限制，是warning限制，-H可以设置硬，-S可以设置软，如果修改的时候没有添加参数，则会同时修改软硬限制；<br>　　hard nofile的作用仅仅是限制soft nofile的大小，当我们调用setrlimit设置nofile的时候，如果传入的soft nofile大于hard nofile则会返回失败。这样听起来似乎hard nofile没什么用因为很多时候我们都习惯于一起把soft nofile和hard nofile设置成一个值，但是比较安全的做法是只修改soft nofile，非必须不要修改hard nofile，改小一般不是我们想要的，但是改大hard nofile甚至超过nr_open很容易造成系统资源耗尽，导致其他进程和系统故障。最好先用getrlimit获取现在的hard nofile，然后在setrlimit时传入这个值，可以保证不修改hard nofile<img src="/2018/01/31/fd-limit/nofile限制.png"></li><li>file-max(/proc/sys/fs/file-max)<br>　　内核可分配的文件句柄的数量限制—kernel-level；<img src="/2018/01/31/fd-limit/filemax限制.png"></li><li>nr_open(/proc/sys/fs/nr_open)<br>　　单个进程可以分配的最大文件句柄数。<img src="/2018/01/31/fd-limit/nropen限制.png"><h3 id="文件打开流程"><a href="#文件打开流程" class="headerlink" title="文件打开流程"></a>文件打开流程</h3>　　三个参数对文件打开流程的影响，文件的打开主要分两步，即申请fd和创建文件结构两个过程，nofile和nr_open在第一个过程起作用，file-max在第二个过程起作用。nofile直接限制fd的申请，nr_open限制文件描述符表的扩展，间接限制了fd的申请，file-max限制文件的实际创建过程。<br>　　<img src="/2018/01/31/fd-limit/stream_copy.png"><h3 id="do-sys-open函数"><a href="#do-sys-open函数" class="headerlink" title="do_sys_open函数"></a>do_sys_open函数</h3>　　用户调用open时，产生中断进入内核态，内核调用do_sys_open函数：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_sys_open</span><span class="params">(<span class="keyword">int</span> dfd, <span class="keyword">const</span> <span class="keyword">char</span> __user *filename, <span class="keyword">int</span> flags, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">open_flags</span> <span class="title">op</span>;</span></span><br><span class="line">    <span class="comment">// 根据传入的参数构造open_flags结构</span></span><br><span class="line">    <span class="keyword">int</span> lookup = build_open_flags(flags, mode, &amp;op);</span><br><span class="line">    <span class="comment">// 对文件名做长度检测s</span></span><br><span class="line">    <span class="keyword">char</span> *tmp = getname(filename); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = PTR_ERR(tmp);</span><br><span class="line">    <span class="keyword">if</span> (!IS_ERR(tmp)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据flags获取一个空闲的fd，此处为关键之一</span></span><br><span class="line">        fd = get_unused_fd_flags(flags); </span><br><span class="line">        <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) </span><br><span class="line">        &#123;    </span><br><span class="line">            <span class="comment">// 打开指定文件，并和之前获取的fd关联，此处为关键之二</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> = <span class="title">do_filp_open</span>(<span class="title">dfd</span>, <span class="title">tmp</span>, &amp;<span class="title">op</span>, <span class="title">lookup</span>);</span>  </span><br><span class="line">            <span class="keyword">if</span> (IS_ERR(f)) </span><br><span class="line">            &#123; </span><br><span class="line">                put_unused_fd(fd);</span><br><span class="line">                fd = PTR_ERR(f);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                fsnotify_open(f);</span><br><span class="line">                fd_install(fd, f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        putname(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;出现Socket/File: Can’t open so many files问题，任何*nux系统，限制数都可以由ulimit或setrlimit来设置。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://huaixuzhi.github.io/categories/Linux/"/>
    
    
      <category term="基础知识" scheme="http://huaixuzhi.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="架构" scheme="http://huaixuzhi.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>设计并使用断言</title>
    <link href="http://huaixuzhi.github.io/2018/01/31/my-assert/"/>
    <id>http://huaixuzhi.github.io/2018/01/31/my-assert/</id>
    <published>2018-01-31T01:55:30.000Z</published>
    <updated>2018-03-07T06:10:37.649Z</updated>
    
    <content type="html"><![CDATA[<p>我们用assert来表示我们相信某个逻辑表达式为真。<br>　　例如assert(n&gt;=0)在n为0或更大时什么都不做，但在n为负值时会报告某种错误（或许还会调用调试器）。<br><a id="more"></a></p><h3 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h3><p>　　assert是个只有定义了DEBUG才起作用的宏，若其参数的计算结果为假，则终止程序执行。<br>　　正是因为要求程序的调试版本和交付版本行为完全相同，所以才不把assert 作为函数,而把它作为宏。如果把assert 作为函数的话，其调用就会引起不期望的内存或代码的兑换。</p><h3 id="自己定义宏ASSERT的方法"><a href="#自己定义宏ASSERT的方法" class="headerlink" title="自己定义宏ASSERT的方法"></a>自己定义宏ASSERT的方法</h3><p>　　使用断言对函数参数进行确认<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="keyword">void</span> _Assert(<span class="keyword">char</span>* , <span class="keyword">unsigned</span>); <span class="comment">/* 原型*/</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASSERT(f) \</span></span><br><span class="line">    <span class="keyword">if</span>(f) \</span><br><span class="line">        <span class="literal">NULL</span>; \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        _Assert(__FILE__ , __LINE__)</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">    #define ASSERT(f) <span class="literal">NULL</span></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>　　分析:若定义了DEBUG，ASSERT将被扩展为一个if语句，否则的话，ASSERT为NULL，即无作为。也许大哥们认为_Assert调用的 ) 后需要一个分号，其实用户在使用ASSERT的时候，会给出的。<br>　　当ASSERT失败时，会使用到预处理程序，根据宏<em>FILE</em>、<em>LINE</em>提供的文件名及行号参数调用_Assert。_Assert在标准错误输出设备stderr上打印一条错误信息，然后终止:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Assert(<span class="keyword">char</span>* strFile, <span class="keyword">unsigned</span> uLine)</span><br><span class="line">&#123;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, “\nAssertion failed: %s, line %u\n”,strFile, uLine);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　在执行abort 之前，需要调用fflush 将所有的缓冲输出写到标准输出设备stdout 上。同样，如果stdout 和stderr 都指向同一个设备，fflush stdout 仍然要放在fflush stderr之前，以确保只有在所有的输出都送到stdout之后，fprintf 才显示相应的错误信息。<br>　　现在如果用NULL 指针调用memcpy，ASSERT 就会抓住这个错误，并显示出如下的错误信息：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Assertion failed: <span class="keyword">string</span>.c , <span class="built_in">line</span> <span class="number">153</span></span><br></pre></td></tr></table></figure></p><h3 id="无意义，意味着要避开"><a href="#无意义，意味着要避开" class="headerlink" title="无意义，意味着要避开"></a>无意义，意味着要避开</h3><p>　　要从程序中删去无定义的特性，或者使用断言来检查出无定义特性的非法使用!!<br>　　eg:搞一下memcpy的实现，增加一个可以验证两个内存块绝不重叠的断言<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* memcpy ─── 拷贝不重叠的内存块*/</span></span><br><span class="line"><span class="keyword">void</span> memcpy(<span class="keyword">void</span>* pvTo, <span class="keyword">void</span>* pvFrom, size_t <span class="keyword">size</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* pbTo = (<span class="keyword">byte</span>*)pvTo;</span><br><span class="line">    <span class="keyword">void</span>* pbFrom = (<span class="keyword">byte</span>*)pvFrom;</span><br><span class="line">    ASSERT(pvTo != <span class="keyword">NULL</span> &amp;&amp; pvFrom != <span class="keyword">NULL</span>);</span><br><span class="line">    ASSERT(pbTo&gt;=pbFrom+<span class="keyword">size</span> || pbFrom&gt;=pbTo+<span class="keyword">size</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">size</span>--&gt;<span class="number">0</span>)</span><br><span class="line">        *pbTo++ == *pbFrom++;</span><br><span class="line">    <span class="keyword">return</span>(pvTo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　关于那句重叠检查啊，其实就是这么理解：把两个内存块比作两辆在停车处排成一行等候的轿车，   就可以很容易明白其中的道理。我们知道，如果一辆车的后保险杠在另一辆车的前保险杠之前，    两辆车就不会重叠。上面的检查实现的就是这个思想，那里pbTo 和pbFrom 是两个内存块的“后保险杠”。PbTo+size和pbFrom+size 分别是位于其相应“前保险杠”之前的某个点。</p><h3 id="不要浪费别人的时间"><a href="#不要浪费别人的时间" class="headerlink" title="不要浪费别人的时间"></a>不要浪费别人的时间</h3><p>　　给不清楚的断言加上注释。(做好注释是每个开发者的本分)</p><h3 id="断言是用作检查非法的情况，而不是去处理真正的错误。"><a href="#断言是用作检查非法的情况，而不是去处理真正的错误。" class="headerlink" title="断言是用作检查非法的情况，而不是去处理真正的错误。"></a>断言是用作检查非法的情况，而不是去处理真正的错误。</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们用assert来表示我们相信某个逻辑表达式为真。&lt;br&gt;　　例如assert(n&amp;gt;=0)在n为0或更大时什么都不做，但在n为负值时会报告某种错误（或许还会调用调试器）。&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://huaixuzhi.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="基础知识" scheme="http://huaixuzhi.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="C语言" scheme="http://huaixuzhi.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>直播平台架构案例</title>
    <link href="http://huaixuzhi.github.io/2018/01/25/streaming-architecture/"/>
    <id>http://huaixuzhi.github.io/2018/01/25/streaming-architecture/</id>
    <published>2018-01-25T06:29:57.000Z</published>
    <updated>2018-03-07T06:10:37.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="直播平台整体架构"><a href="#直播平台整体架构" class="headerlink" title="直播平台整体架构"></a>直播平台整体架构</h3><img src="/2018/01/25/streaming-architecture/01.png"><h3 id="视频直播链路"><a href="#视频直播链路" class="headerlink" title="视频直播链路"></a>视频直播链路</h3><img src="/2018/01/25/streaming-architecture/02.png"><h3 id="视频码流转换"><a href="#视频码流转换" class="headerlink" title="视频码流转换"></a>视频码流转换</h3><p>　　不同端，在不同网络环境下，需要不同的码率（视频流需要转换成不同的清晰度），保证传输的流畅性。<br><img src="/2018/01/25/streaming-architecture/03.png"></p><h3 id="播放器的基本实现"><a href="#播放器的基本实现" class="headerlink" title="播放器的基本实现"></a>播放器的基本实现</h3><img src="/2018/01/25/streaming-architecture/04.png"><h3 id="视频相关技术细节"><a href="#视频相关技术细节" class="headerlink" title="视频相关技术细节"></a>视频相关技术细节</h3><img src="/2018/01/25/streaming-architecture/05.png"><h3 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h3><img src="/2018/01/25/streaming-architecture/06.png"><h3 id="不同消息通道的优劣对比"><a href="#不同消息通道的优劣对比" class="headerlink" title="不同消息通道的优劣对比"></a>不同消息通道的优劣对比</h3><img src="/2018/01/25/streaming-architecture/07.png"><h3 id="心跳及房间结构"><a href="#心跳及房间结构" class="headerlink" title="心跳及房间结构"></a>心跳及房间结构</h3><img src="/2018/01/25/streaming-architecture/08.png"><h3 id="用户按需分桶"><a href="#用户按需分桶" class="headerlink" title="用户按需分桶"></a>用户按需分桶</h3><img src="/2018/01/25/streaming-architecture/09.png"><h3 id="固定分桶与按需分桶对比"><a href="#固定分桶与按需分桶对比" class="headerlink" title="固定分桶与按需分桶对比"></a>固定分桶与按需分桶对比</h3><img src="/2018/01/25/streaming-architecture/10.png"><h3 id="关键词及垃圾文本过滤"><a href="#关键词及垃圾文本过滤" class="headerlink" title="关键词及垃圾文本过滤"></a>关键词及垃圾文本过滤</h3><img src="/2018/01/25/streaming-architecture/11.png"><h3 id="大促风险控制"><a href="#大促风险控制" class="headerlink" title="大促风险控制"></a>大促风险控制</h3><img src="/2018/01/25/streaming-architecture/12.png"><h3 id="平台化的挑战"><a href="#平台化的挑战" class="headerlink" title="平台化的挑战"></a>平台化的挑战</h3><img src="/2018/01/25/streaming-architecture/13.png"><p>来源：<br><a href="http://www.cnblogs.com/wintersun/p/5860437.html" target="_blank" rel="noopener">http://www.cnblogs.com/wintersun/p/5860437.html</a></p>]]></content>
    
    <summary type="html">
    
      直播平台架构案例
    
    </summary>
    
      <category term="流媒体" scheme="http://huaixuzhi.github.io/categories/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    
      <category term="流媒体" scheme="http://huaixuzhi.github.io/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>阻塞非阻塞与同步异步</title>
    <link href="http://huaixuzhi.github.io/2018/01/24/network-basic-01/"/>
    <id>http://huaixuzhi.github.io/2018/01/24/network-basic-01/</id>
    <published>2018-01-24T09:28:21.000Z</published>
    <updated>2018-03-07T06:10:37.640Z</updated>
    
    <content type="html"><![CDATA[<p>阻塞和非阻塞描述的是一种状态，同步和非同步描述的是行为方式。</p><h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p>关注的是<b>程序在等待调用结果（消息、返回值）时的状态。</b><br><b>阻塞调用</b>是指，在调用结果返回之前，当前的线程会被挂起，调用线程只有在得到结果之后才会返回。<br><b>非阻塞调用</b>，指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><h3 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h3><p>关注的是<b>消息通信机制。</b><br><b>同步</b>，指在发出“调用”时，没有得到结果之前，这个“调用”就不返回，但是一旦“调用”返回，就得到返回值了。也可以说，是调用者在主动等待“调用”结果。<br><b>异步</b>，“调用”发出之后，就直接返回，没有返回结果。也可以说，当一个异步过程调用发出后，调用者不会立刻得到结果，而是被调用者通过状态、通知来通知调用者，或者通过回调函数来处理这个调用。</p><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><img src="/2018/01/24/network-basic-01/IO.png">]]></content>
    
    <summary type="html">
    
      阻塞和非阻塞描述的是一种状态，同步和非同步描述的是行为方式。
    
    </summary>
    
      <category term="网络" scheme="http://huaixuzhi.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="基础知识" scheme="http://huaixuzhi.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="面试" scheme="http://huaixuzhi.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>GDB常用命令</title>
    <link href="http://huaixuzhi.github.io/2018/01/18/gdb-manual/"/>
    <id>http://huaixuzhi.github.io/2018/01/18/gdb-manual/</id>
    <published>2018-01-18T07:21:51.000Z</published>
    <updated>2018-03-13T03:50:11.238Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GDB示例程序"><a href="#GDB示例程序" class="headerlink" title="GDB示例程序"></a>GDB示例程序</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">hchen/test&gt; cc -g tst.c -o tst</span><br><span class="line">使用GDB调试：</span><br><span class="line">hchen/test&gt; gdb tst &lt;---------- 启动GDB</span><br><span class="line">GNU gdb 5.1.1</span><br><span class="line">Copyright 2002 Free Software Foundation, Inc.</span><br><span class="line">GDB is free software, covered by the GNU General Public License, <span class="keyword">and</span> you are</span><br><span class="line">welcome <span class="keyword">to</span> change it <span class="keyword">and</span>/<span class="keyword">or</span> distribute copies of it under certain conditions.</span><br><span class="line">Type <span class="string">"show copying"</span> <span class="keyword">to</span> see the conditions.</span><br><span class="line">There is absolutely <span class="literal">no</span> warranty <span class="keyword">for</span> GDB.<span class="built_in"> Type </span><span class="string">"show warranty"</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">"i386-suse-linux"</span><span class="built_in">..</span>.</span><br><span class="line">(gdb) l &lt;-------------------- l命令相当于list， 从第一行开始例出原码。</span><br><span class="line">1 #include &lt;stdio.h&gt;</span><br><span class="line">2</span><br><span class="line">3 int func(int n)</span><br><span class="line">4 &#123;</span><br><span class="line">5 int <span class="attribute">sum</span>=0,i;</span><br><span class="line">6 <span class="keyword">for</span>(<span class="attribute">i</span>=0; i&lt;n; i++)</span><br><span class="line">7 &#123;</span><br><span class="line">8 sum+=i;</span><br><span class="line">9 &#125;</span><br><span class="line">10 return sum;</span><br><span class="line">(gdb) &lt;-------------------- 直接回车表示， 重复上一次命令</span><br><span class="line">11 &#125;</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14 main()</span><br><span class="line">15 &#123;</span><br><span class="line">16 int i;</span><br><span class="line">17 long result = 0;</span><br><span class="line">18 <span class="keyword">for</span>(<span class="attribute">i</span>=1; i&lt;=100; i++)</span><br><span class="line">19 &#123;</span><br><span class="line">20 result += i;</span><br><span class="line">(gdb) break 16 &lt;-------------------- 设置断点， 在源程序第16行处。</span><br><span class="line">Breakpoint 1 at 0x8048496: file tst.c, line 16.</span><br><span class="line">(gdb) break func &lt;-------------------- 设置断点， 在函数func()入口处。</span><br><span class="line">Breakpoint 2 at 0x8048456: file tst.c, line 5.</span><br><span class="line">(gdb) <span class="builtin-name">info</span> break &lt;-------------------- 查看断点信息。</span><br><span class="line">Num<span class="built_in"> Type </span>Disp Enb<span class="built_in"> Address </span>What</span><br><span class="line">1 breakpoint keep y 0x08048496 <span class="keyword">in</span> main at tst.c:16</span><br><span class="line">2 breakpoint keep y 0x08048456 <span class="keyword">in</span> func at tst.c:5</span><br><span class="line">(gdb) r &lt;--------------------- 运行程序， run命令简写</span><br><span class="line">Starting program: /home/hchen/test/tst</span><br><span class="line">Breakpoint 1, main () at tst.c:17 &lt;---------- 在断点处停住。</span><br><span class="line">17 long result = 0;</span><br><span class="line">(gdb) n &lt;--------------------- 单条语句执行， next命令简写。</span><br><span class="line">18 <span class="keyword">for</span>(<span class="attribute">i</span>=1; i&lt;=100; i++)</span><br><span class="line">(gdb) n</span><br><span class="line">20 result += i;</span><br><span class="line">(gdb) n</span><br><span class="line">18 <span class="keyword">for</span>(<span class="attribute">i</span>=1; i&lt;=100; i++)</span><br><span class="line">(gdb) n</span><br><span class="line">20 result += i;</span><br><span class="line">(gdb) c &lt;--------------------- 继续运行程序， continue命令简写。</span><br><span class="line">Continuing.</span><br><span class="line">result[1-100] = 5050 &lt;----------程序输出。</span><br><span class="line">Breakpoint 2, func (<span class="attribute">n</span>=250) at tst.c:5</span><br><span class="line">5 int <span class="attribute">sum</span>=0,i;</span><br><span class="line">(gdb) n</span><br><span class="line">6 <span class="keyword">for</span>(<span class="attribute">i</span>=1; i&lt;=n; i++)</span><br><span class="line">(gdb) p i &lt;--------------------- 打印变量i的值， print命令简写。</span><br><span class="line"><span class="variable">$1</span> = 134513808</span><br><span class="line">(gdb) n</span><br><span class="line">8 sum+=i;</span><br><span class="line">(gdb) n</span><br><span class="line">6 <span class="keyword">for</span>(<span class="attribute">i</span>=1; i&lt;=n; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="variable">$2</span> = 1</span><br><span class="line">(gdb) n</span><br><span class="line">8 sum+=i;</span><br><span class="line">(gdb) p i</span><br><span class="line"><span class="variable">$3</span> = 2</span><br><span class="line">(gdb) n</span><br><span class="line">6 <span class="keyword">for</span>(<span class="attribute">i</span>=1; i&lt;=n; i++)</span><br><span class="line">(gdb) p sum</span><br><span class="line"><span class="variable">$4</span> = 3</span><br><span class="line">(gdb) bt &lt;--------------------- 查看函数堆栈。</span><br><span class="line"><span class="comment">#0 func (n=250) at tst.c:5</span></span><br><span class="line"><span class="comment">#1 0x080484e4 in main () at tst.c:24</span></span><br><span class="line"><span class="comment">#2 0x400409ed in __libc_start_main () from /lib/libc.so.6</span></span><br><span class="line">(gdb) finish &lt;--------------------- 退出函数。</span><br><span class="line"><span class="builtin-name">Run</span> till exit <span class="keyword">from</span> #0 func (<span class="attribute">n</span>=250) at tst.c:5</span><br><span class="line">0x080484e4 <span class="keyword">in</span> main () at tst.c:24</span><br><span class="line">24 printf(<span class="string">"result[1-250] = %d n"</span>, func(250) );</span><br><span class="line">Value returned is <span class="variable">$6</span> = 31375</span><br><span class="line">(gdb) c &lt;--------------------- 继续运行。</span><br><span class="line">Continuing.</span><br><span class="line">result[1-250] = 31375 &lt;----------程序输出。</span><br><span class="line">Program exited with code 027. &lt;--------程序退出， 调试结束。</span><br><span class="line">(gdb) q &lt;--------------------- 退出gdb。</span><br><span class="line">hchen/test&gt;</span><br></pre></td></tr></table></figure><h3 id="1-gdb调试线程"><a href="#1-gdb调试线程" class="headerlink" title="1.gdb调试线程"></a>1.gdb调试线程</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> <span class="symbol">&lt;linespec&gt;</span> thread <span class="symbol">&lt;threadno&gt;</span> <span class="keyword">if</span>...</span><br></pre></td></tr></table></figure><p>　　ID是GDB分配的，可以通过info threads命令查看正在运行程序中的线程信息。</p><h3 id="2-gdb调试正在运行的进程"><a href="#2-gdb调试正在运行的进程" class="headerlink" title="2.gdb调试正在运行的进程"></a>2.gdb调试正在运行的进程</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb <span class="tag">&lt;<span class="name">program</span>&gt;</span> <span class="tag">&lt;<span class="name">PID</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb后，<span class="built_in">attach</span> &lt;PID&gt;</span><br></pre></td></tr></table></figure><p>　　gdb接到attach命令后的第一件事儿就是停止进程的运行，所以在调试结束后，我们需要detach命令通知调试的进程继续运行。</p><h3 id="3-gdb环境下，是可以运行Shell命令的"><a href="#3-gdb环境下，是可以运行Shell命令的" class="headerlink" title="3.gdb环境下，是可以运行Shell命令的"></a>3.gdb环境下，是可以运行Shell命令的</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span> &lt;<span class="built_in">make</span>-args&gt;</span><br></pre></td></tr></table></figure><p>　　在gdb中执行make命令重新build自己的程序；<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">args</span> <span class="symbol">&lt;argss&gt;</span></span><br></pre></td></tr></table></figure></p><p>　　指定运行时的参数；<br><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">path</span> &lt;<span class="built_in">dir</span>&gt;</span><br></pre></td></tr></table></figure></p><p>　　设定程序的运行路径；<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">show paths</span></span><br></pre></td></tr></table></figure></p><p>　　查看程序的运行路径；<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> environment varname [=<span class="keyword">value</span>]</span><br></pre></td></tr></table></figure></p><p>　　设置环境变量，如set env USER=hchen；<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show environment <span class="string">[varname]</span></span><br></pre></td></tr></table></figure></p><p>　　查看环境变量。</p><h3 id="4-gdb的断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）"><a href="#4-gdb的断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）" class="headerlink" title="4.gdb的断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）"></a>4.gdb的断点（BreakPoint）、观察点（WatchPoint）、捕捉点（CatchPoint）</h3><p>　　<b>①断点：break filename:linenum </b><br>　　break…if <condition>，在condition条件成立时break，例如在可以在循环体里面设置break if i=100；<br>　　<b>②观察点，watch <expr>，一般用来观察某个表达式（变量也是一种表达式）的值是否有变化，如果有变化，则停止程序；</expr></b><br>　　rwatch <expr>，当表达式expr被读时，停住程序；<br>　　awatch <expr>，当表达式expr被写时，停住程序；<br>　　info watchpoints，列出当前设置的所有观察点；<br>　　<b>③捕捉点，catch <event>，用来捕捉程序运行时的一些事件，event可以是如下内容：</event></b><br>　　throw 一个C++抛出的异常。（ throw为关键字）<br>　　catch 一个C++捕捉到的异常。（ catch为关键字）<br>　　exec 调用系统调用exec时。（ exec为关键字， 目前此功能只在HP-UX下有用）<br>　　fork 调用系统调用fork时。（ fork为关键字， 目前此功能只在HP-UX下有用）<br>　　vfork 调用系统调用vfork时。（ vfork为关键字， 目前此功能只在HP-UX下有用）<br>　　load 或 load <libname> 载入共享库（ 动态链接库）时。（ load为关键字， 目前此功能只在HP-UX下有用）<br>　　unload 或 unload <libname> 卸载共享库（ 动态链接库）时。（ unload为关键字， 目前此功能只在HP-UX下有用）</libname></libname></expr></expr></condition></p><h3 id="5-gdb调试信号"><a href="#5-gdb调试信号" class="headerlink" title="5.gdb调试信号"></a>5.gdb调试信号</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handle <span class="tag">&lt;<span class="name">signal</span>&gt;</span> <span class="tag">&lt;<span class="name">keywords..</span>&gt;</span></span><br></pre></td></tr></table></figure><p><b><br>        [signal]：</b><br>    　　SIGINT – 中断，Ctrl+C<br>    　　SIGBOS – 硬件故障<br>    　　SIGCHLD – 进程状态改变<br>    　　SIGKILL – 进程终止<br>    <b>[keywords]可以是以下几种关键字的一个或多个</b><br>    　　nostop – 当被调试的程序收到信号时，GDB不会停住程序的运行， 但会打出消息告诉你收到这种信号。<br>    　　stop – 当被调试的程序收到信号时，GDB会停住你的程序。<br>   　　 print – 当被调试的程序收到信号时，GDB会显示出一条信息。<br>    　　noprint – 被调试的程序收到信号时，GDB不会告诉你收到信号的信息。<br>    　　pass noignore – 当被调试的程序收到信号时，GDB不处理信号。这表示， GDB会把这个信号交给被调试程序会处理。<br>    　　nopass ignore – 当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。</p>]]></content>
    
    <summary type="html">
    
      GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。
    
    </summary>
    
      <category term="Linux" scheme="http://huaixuzhi.github.io/categories/Linux/"/>
    
    
      <category term="基础知识" scheme="http://huaixuzhi.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="C语言" scheme="http://huaixuzhi.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>I/O复用函数比较(select/poll/epoll)</title>
    <link href="http://huaixuzhi.github.io/2018/01/05/IO-multiplexing/"/>
    <id>http://huaixuzhi.github.io/2018/01/05/IO-multiplexing/</id>
    <published>2018-01-05T06:29:47.000Z</published>
    <updated>2018-03-07T06:10:37.651Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一。系统函数"><a href="#一。系统函数" class="headerlink" title="一。系统函数"></a>一。系统函数</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>epoll的接口非常简单，一共就三个函数：</p><h4 id="1-int-epoll-create-int-size"><a href="#1-int-epoll-create-int-size" class="headerlink" title="1. int epoll_create(int size);"></a>1. int epoll_create(int size);</h4><p>　　创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p><h4 id="2-int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event"><a href="#2-int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event" class="headerlink" title="2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);"></a>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</h4><p>　　epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：<br>　　EPOLL_CTL_ADD：注册新的fd到epfd中；<br>　　EPOLL_CTL_MOD：修改已经注册的fd的监听事件；<br>　　EPOLL_CTL_DEL：从epfd中删除一个fd；<br>第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事件，struct epoll_event结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>events可以是以下几个宏的集合：<br>　　EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<br>　　EPOLLOUT：表示对应的文件描述符可以写；<br>　　EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br>　　EPOLLERR：表示对应的文件描述符发生错误；<br>　　EPOLLHUP：表示对应的文件描述符被挂断；<br>　　EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br>　　EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p><h4 id="3-int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><a href="#3-int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout" class="headerlink" title="3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);"></a>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</h4><p>　　等待事件的产生，参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。<br>//epoll_wait范围之后应该是一个循环，遍利所有的事件：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">n</span> = 0; <span class="keyword">n</span> &lt; nfds; ++<span class="keyword">n</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果是主socket的事件的话，则表示有新连接进入了，进行新连接的处理</span></span><br><span class="line">    <span class="keyword">if</span>(events[<span class="keyword">n</span>].data.fd == listener) </span><br><span class="line">    &#123;</span><br><span class="line">       client = accept(listener, (struct sockaddr *) &amp;<span class="keyword">local</span>,  &amp;addrlen);</span><br><span class="line">       <span class="keyword">if</span>(client &lt; 0)</span><br><span class="line">       &#123;</span><br><span class="line">           perror(<span class="string">"accept"</span>);</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将新连接置于非阻塞模式</span></span><br><span class="line">       setnonblocking(client); </span><br><span class="line">       <span class="comment">//并且将新连接也加入EPOLL的监听队列。</span></span><br><span class="line">       <span class="comment">//注意，这里的参数EPOLLIN | EPOLLET并没有设置对写socket的监听，</span></span><br><span class="line">       <span class="comment">//如果有写操作的话，这个时候epoll是不会返回事件的，</span></span><br><span class="line">       <span class="comment">//如果要对写操作也监听的话，应该是EPOLLIN | EPOLLOUT | EPOLLET</span></span><br><span class="line">       ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">       ev.data.fd = client;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//设置好event之后，将这个新的event通过epoll_ctl,加入到epoll的监听队列里面，</span></span><br><span class="line">       <span class="comment">//这里用EPOLL_CTL_ADD 来加一个新的 epoll事件，通过EPOLL_CTL_DEL来减少一个epoll事件，</span></span><br><span class="line">       <span class="comment">//通过EPOLL_CTL_MOD来改变一个事件的监听方式。</span></span><br><span class="line">       <span class="keyword">if</span> (epoll_ctl(kdpfd, EPOLL_CTL_ADD, client, &amp;ev) &lt; 0) </span><br><span class="line">       &#123;  </span><br><span class="line">           fprintf(stderr, "epoll <span class="keyword">set</span> insertion <span class="keyword">error</span>: fd=%d0, client);</span><br><span class="line">           <span class="keyword">return</span> -1;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果不是主socket的事件的话，则代表是一个用户socket的事件</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//则来处理这个用户socket的事情，比如说read(fd,xxx)之类的，或者一些其他的处理</span></span><br><span class="line">        do_use_fd(events[<span class="keyword">n</span>].data.fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>实例使用：</b><br>EPOLL模型似乎只有一种格式<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">TRUE</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//等待EPOLL时间的发生，相当于监听</span></span><br><span class="line">  <span class="keyword">int</span> nfds = epoll_wait (m_epoll_fd, m_events, MAX_EVENTS, EPOLL_TIME_OUT); </span><br><span class="line">  <span class="keyword">if</span> (nfds &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  m_bOnTimeChecking = <span class="keyword">FALSE</span>;</span><br><span class="line">  G_CurTime = time(<span class="keyword">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nfds; i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//如果新监测到一个SOCKET用户连接到了绑定的SOCKET端口，建立新的连接。</span></span><br><span class="line">       <span class="keyword">if</span> (m_events[i].data.fd == m_listen_sock_fd)        &#123;</span><br><span class="line">          OnAcceptSockEpoll ();</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="comment">//如果是已经连接的用户，并且收到数据，那么进行读入。</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (m_events[i].events &amp; EPOLLIN) </span><br><span class="line">       &#123;</span><br><span class="line">          OnReadEpoll (i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//查看当前的活动连接是否有需要写出的数据。</span></span><br><span class="line">       OnWriteEpoll (i); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      PRINTF (<span class="string">"CATCH捕获错误/n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  m_bOnTimeChecking = <span class="keyword">TRUE</span>;</span><br><span class="line">  <span class="comment">//进行一些定时的操作，主要就是删除一些短线用户等</span></span><br><span class="line">  OnTimer ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Epoll模型主要负责对大量并发用户的请求进行及时处理，完成服务器与客户端的数据交互。其具体的实现步骤如下：<br>(a) 使用epoll_create()函数创建文件描述，设定将可管理的最大socket描述符数目。<br>(b) 创建与epoll关联的接收线程，应用程序可以创建多个接收线程来处理epoll上的读通知事件，线程的数量依赖于程序的具体需要。<br>(c) 创建一个侦听socket描述符ListenSock；将该描述符设定为非阻塞模式，调用Listen（）函数在套接字上侦听有无新的连接请求，在epoll_event结构中设置要处理的事件类型EPOLLIN，工作方式为 epoll_ET，以提高工作效率，同时使用epoll_ctl()注册事件，最后启动网络监视线程。<br>(d) 网络监视线程启动循环，epoll_wait()等待epoll事件发生。<br>(e) 如果epoll事件表明有新的连接请求，则调用accept（）函数，将用户socket描述符添加到epoll_data联合体，同时设定该描述符为非阻塞，并在epoll_event结构中设置要处理的事件类型为读和写，工作方式为epoll_ET.<br>(f) 如果epoll事件表明socket描述符上有数据可读，则将该socket描述符加入可读队列，通知接收线程读入数据，并将接收到的数据放入到接收数据的链表中，经逻辑处理后，将反馈的数据包放入到发送数据链表中，等待由发送线程发送。</p><h3 id="二。epoll实现原理"><a href="#二。epoll实现原理" class="headerlink" title="二。epoll实现原理"></a>二。epoll实现原理</h3><p>　　select和poll在每次调用时，都会把监控的所有socket传递给系统，也就是说，需要将用户态的socket列表拷贝到内核态（如果是数以万计的句柄会导致每次要拷贝几十到几百KB的内存到内核态）。<br>　　epoll在调用epoll_create时，向内核注册一个文件系统，并创建file结点。epoll在被内核初始化时，会开辟内核高速缓冲区，用于放置我们需要监控的socket（epoll_ctl传入），这些socket会以红黑树的形式保存在内核缓存中，支持查找、插入、删除操作；同时会建立一个list表，用于存储准备就绪的事件，当epoll_wait调用时，仅需要观察这个list链表中是否有数据即可，有数据就返回，没数据就sleep了。<br>　　epoll的准备就绪list链表如何维护？在执行epoll_ctl时，除了把socket放到epoll文件系统epfd对应的红黑树之外，还会给内核中断处理程序注册一个回调函数，如果此句柄的中断到达，则将其放入准备就绪的list链表中。<br><b>总结epoll的处理：</b><br>　　执行epoll_create时，创建了红黑树和就绪链表，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。</p><h3 id="三。LT和ET模式"><a href="#三。LT和ET模式" class="headerlink" title="三。LT和ET模式"></a>三。LT和ET模式</h3><p><b>LT（Level Triggered，水平触发）</b><br>　　效率会低于ET触发，尤其在大并发，大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况。<br><b>ET（Edge Triggered，边沿触发）</b><br>　　效率非常高，在并发，大流量的情况下，会比LT少很多epoll的系统调用，因此效率高。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况。<br><b>总结：</b><br>　　当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait干了件事，就是检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。所以，非ET的句柄，只要它上面还有事件，epoll_wait每次都会返回这个句柄。</p><h3 id="四。select、poll、epoll三组I-O复用函数比较"><a href="#四。select、poll、epoll三组I-O复用函数比较" class="headerlink" title="四。select、poll、epoll三组I/O复用函数比较"></a>四。select、poll、epoll三组I/O复用函数比较</h3><table><thead><tr><th width="16%," style="text-align:center">系统调用</th><th width="28%," style="text-align:center">select</th><th width="28%," style="text-align:center">poll</th><th width="28%," style="text-align:center">epoll</th></tr></thead><tbody><tr><td style="text-align:center">事件管理</td><td style="text-align:center">用户通过3个参数分别传入感兴趣的可读、可写及异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件。所以用户每次调用select都要重置这3个参数。</td><td style="text-align:center">统一处理所有事件类型，只需一个事件集参数。用户通过pollfd.events传入感兴趣事件，内核通过修改polled.revents反馈其中就绪的事件。</td><td style="text-align:center">内核通过一个事件表直接管理用户感兴趣的所有事件，每次调用epoll_wait时，无须反复传入用户感兴趣的事件，epoll_wait系统调用的参数events仅用于反馈就绪的事件。</td></tr><tr><td style="text-align:center">索引就绪FD的时间复杂度</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">最大支持文件描述符</td><td style="text-align:center">一般有最大值限制</td><td style="text-align:center">65 535</td><td style="text-align:center">65 535</td></tr><tr><td style="text-align:center">工作模式</td><td style="text-align:center">LT</td><td style="text-align:center">LT</td><td style="text-align:center">支持ET模式</td></tr><tr><td style="text-align:center">内核实现和工作效率</td><td style="text-align:center">采用轮询方式来检测就绪事件</td><td style="text-align:center">采用轮询方式来检测就绪事件</td><td style="text-align:center">采用回调方式来检测就绪事件</td></tr></tbody></table><p>参考：<br><a href="http://www.cppblog.com/Khan/archive/2008/04/02/46013.html" target="_blank" rel="noopener">http://www.cppblog.com/Khan/archive/2008/04/02/46013.html</a><br><a href="http://www.cnblogs.com/charlesblc/p/6242479.html" target="_blank" rel="noopener">http://www.cnblogs.com/charlesblc/p/6242479.html</a><br><a href="http://www.cnblogs.com/charlesblc/p/5538363.html" target="_blank" rel="noopener">http://www.cnblogs.com/charlesblc/p/5538363.html</a><br><a href="http://blog.csdn.net/wangxmin2005/article/details/7587525" target="_blank" rel="noopener">http://blog.csdn.net/wangxmin2005/article/details/7587525</a></p>]]></content>
    
    <summary type="html">
    
      epoll - I/O event notification facility
    
    </summary>
    
      <category term="网络" scheme="http://huaixuzhi.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="基础知识" scheme="http://huaixuzhi.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="面试" scheme="http://huaixuzhi.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>memcpy函数实现及其优化</title>
    <link href="http://huaixuzhi.github.io/2018/01/05/my-memcpy-realization/"/>
    <id>http://huaixuzhi.github.io/2018/01/05/my-memcpy-realization/</id>
    <published>2018-01-05T02:25:15.000Z</published>
    <updated>2018-03-07T06:10:37.656Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>SYNOPSIS<br>　　void <em>memcpy(void </em>dest, const void *src, size_t n);<br>DESCRIPTION<br>　　The  memcpy()  function  copies n bytes from memory area src to memory area dest. The memory areas must not overlap.  Use memmove(3) if the memory areas do overlap.<br>RETURN VALUE<br>　　The memcpy() function returns a pointer to dest.</p><h3 id="1-基本的实现"><a href="#1-基本的实现" class="headerlink" title="1.基本的实现"></a>1.基本的实现</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *mymemcpy(<span class="keyword">void</span> *dst,<span class="keyword">const</span> <span class="keyword">void</span> *src,size_t num)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//安全检查</span></span><br><span class="line">    <span class="keyword">assert</span>((dst != NULL)&amp;&amp;(src != NULL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//byte 既为unsigned char类型</span></span><br><span class="line">    <span class="keyword">byte</span> *psrc = (<span class="keyword">byte</span> *)src;</span><br><span class="line">    <span class="keyword">byte</span> *pdst = (<span class="keyword">byte</span> *)dst;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *pdst++ = *psrc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-考虑内存重叠"><a href="#2-考虑内存重叠" class="headerlink" title="2.考虑内存重叠"></a>2.考虑内存重叠</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *mymemcpy(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, size_t num)      </span><br><span class="line">&#123;      </span><br><span class="line">    <span class="comment">//安全检查  </span></span><br><span class="line">    <span class="keyword">assert</span>((dst != NULL) &amp;&amp; (src != NULL));      </span><br><span class="line">    <span class="comment">//防止内存重叠  </span></span><br><span class="line">    <span class="keyword">assert</span>((dst &gt;= src+num) || (src &gt; dst+num));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> *pdst = (<span class="keyword">byte</span> *)dst;      </span><br><span class="line">    <span class="keyword">byte</span> *psrc = (<span class="keyword">byte</span> *)src;      </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num-- &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *pdst++ = *psrc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-内存重叠处理"><a href="#3-内存重叠处理" class="headerlink" title="3.内存重叠处理"></a>3.内存重叠处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymemcpy</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//安全检查  </span></span><br><span class="line">    assert((dst != <span class="literal">NULL</span>) &amp;&amp; (src != <span class="literal">NULL</span>)); </span><br><span class="line"></span><br><span class="line">    byte *pdst = (byte *)dst;      </span><br><span class="line">    byte *psrc = (byte *)src;      </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若目标起始地址在源串所占的地址之间，高字节向低字节进行拷贝</span></span><br><span class="line">    <span class="keyword">if</span> ((pdst &gt; psrc) &amp;&amp; (pdst &lt; psrc+num))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = num<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">                pdst[i] = psrc[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若目标地址与源地址不重叠，则低字节向高字节进行拷贝</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">        &#123;</span><br><span class="line">                pdst[i] = psrc[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pdst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4.性能优化"></a>4.性能优化</h3><p>　　以上都是byte到byte的拷贝，但在地址对齐的情况下，memcpy会使用CPU字长(32bit或64bit)进行拷贝，当然，在地址不对齐的情况下，还是一个个字节拷的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mymemcpy</span><span class="params">(<span class="keyword">void</span> *dst,<span class="keyword">const</span> <span class="keyword">void</span> *src,<span class="keyword">size_t</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//安全检查  </span></span><br><span class="line">    assert((dst != <span class="literal">NULL</span>) &amp;&amp; (src != <span class="literal">NULL</span>)); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//32bitCPU，按4字节拷贝</span></span><br><span class="line">    <span class="keyword">int</span> wordnum = num/<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//剩余的按字节拷贝</span></span><br><span class="line">    <span class="keyword">int</span> slice = num%<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> * pintsrc = (<span class="keyword">int</span> *)src;</span><br><span class="line">    <span class="keyword">int</span> * pintdst = (<span class="keyword">int</span> *)dst;</span><br><span class="line">    <span class="keyword">while</span>(wordnum--)</span><br><span class="line">    &#123;</span><br><span class="line">        *pintdst++ = *pintsrc++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(slice--)</span><br><span class="line">    &#123;</span><br><span class="line">        *((<span class="keyword">char</span> *)pintdst++) = *((<span class="keyword">char</span> *)pintsrc++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-memcpy和memmove的区别"><a href="#5-memcpy和memmove的区别" class="headerlink" title="5.memcpy和memmove的区别"></a>5.memcpy和memmove的区别</h3><p>　　void <em>memmove(void </em>dest, const void *source, size_t count)<br>　　memmove用于从source拷贝count个字符到dest，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中。<br>　　memcpy中dest和source中的区域不能重叠，否则会出现未知结果。</p>]]></content>
    
    <summary type="html">
    
      The  memcpy()  function  copies n bytes from memory area src to memory area dest.  The memory areas must not overlap.
    
    </summary>
    
      <category term="杂谈" scheme="http://huaixuzhi.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="基础知识" scheme="http://huaixuzhi.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="面试" scheme="http://huaixuzhi.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>去除字符串中的特定字符</title>
    <link href="http://huaixuzhi.github.io/2018/01/04/del-char-interview/"/>
    <id>http://huaixuzhi.github.io/2018/01/04/del-char-interview/</id>
    <published>2018-01-04T07:29:13.000Z</published>
    <updated>2018-03-07T06:10:37.672Z</updated>
    
    <content type="html"><![CDATA[<p>去除字符串中的指定字符，要求不进行内存申请，尽量少的时间复杂度。<br><a id="more"></a><br>代码如下：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> <span class="function"><span class="keyword">func</span><span class="params">(char cstr[])</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> j = <span class="number">0</span>, i = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">for</span>(i<span class="comment">; cstr[i] != '\0'; i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cstr[i] != <span class="string">'o'</span>)</span><br><span class="line">        &#123;           </span><br><span class="line">            cstr[j] = cstr[i]<span class="comment">;    </span></span><br><span class="line">            j++<span class="comment">;       </span></span><br><span class="line">        &#125;              </span><br><span class="line">    &#125;            </span><br><span class="line">    cstr[j] = <span class="string">'\0'</span><span class="comment">;    </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    char cstr[] = <span class="string">"welcome to fuck me"</span><span class="comment">;</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">(cstr)</span>;</span></span><br><span class="line">    printf(<span class="string">"%s\n"</span>, cstr)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">welcme t fuck <span class="keyword">me</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去除字符串中的指定字符，要求不进行内存申请，尽量少的时间复杂度。&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://huaixuzhi.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="基础知识" scheme="http://huaixuzhi.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="面试" scheme="http://huaixuzhi.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>负载均衡</title>
    <link href="http://huaixuzhi.github.io/2017/12/22/load-balance/"/>
    <id>http://huaixuzhi.github.io/2017/12/22/load-balance/</id>
    <published>2017-12-22T03:22:27.000Z</published>
    <updated>2018-03-07T06:10:37.646Z</updated>
    
    <content type="html"><![CDATA[<h3 id="负载均衡的概念："><a href="#负载均衡的概念：" class="headerlink" title="负载均衡的概念："></a>负载均衡的概念：</h3><p>　　负载均衡（Load Balance）建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。<br>　　负载均衡有两方面的含义：首先，大量的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间；其次，单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高。</p><h3 id="四层负载"><a href="#四层负载" class="headerlink" title="四层负载"></a>四层负载</h3><p>　　即TCP代理，用于在网络四层的负载分担。<br>　　基于IP+端口的单个报文传输模式，通过虚拟IP+端口接受请求，进行NAT处理，然后再分配到真实的服务器，并记录下这个TCP或者UDP的流量所对应的真实服务器，后续此连接的所有流量都同样转发到同一台真实服务器进行处理。<br>　　以下图所示的TCP连接为例，代理（负载均衡设备）接收到来自客户的SYN请求时，会选择一个最佳的服务器，并对报文中目标IP地址进行修改（改为后端服务器IP），直接转发。TCP连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只起到一个类似路由转发的作用。<br>　　<img src="/2017/12/22/load-balance/load-balance-4.png"><br>　　四层负载均衡常用于对应TCP应用，例如基于C/S开发的ERP等系统。</p><h3 id="七层负载"><a href="#七层负载" class="headerlink" title="七层负载"></a>七层负载</h3><p>　　是内容交换，通过报文中真正有意义的应用层内容，使用负载均衡设备的服务器选择方式，决定最终选择的内部服务器。<br>　　以TCP为例，客户端先与代理服务器先进行连接（三次握手），然后发送应用层报文，代理服务器接收到后，根据该报文中的特定字段，决定最终选择的内部服务器（代理与客户端、后端服务器都需要建立TCP连接）。<br>　　<img src="/2017/12/22/load-balance/load-balance-7.png"><br>　　七层负载应用场景：<br>　　高可用：例如访问一个网站的用户流量，可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术。很多在后台，例如Nginx或者Apache上部署的功能可以前移到负载均衡设备上，例如客户请求中的Header重写，服务器响应中的关键字过滤或者内容插入等功能。<br>　　安全性：四层模式下这些SYN攻击都会被转发到后端的服务器上；而七层模式下这些SYN攻击自然在负载均衡设备上就截止，不会影响后台服务器的正常运营。</p>]]></content>
    
    <summary type="html">
    
      负载均衡（Load Balance）建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。
    
    </summary>
    
      <category term="架构" scheme="http://huaixuzhi.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="WEB开发" scheme="http://huaixuzhi.github.io/tags/WEB%E5%BC%80%E5%8F%91/"/>
    
      <category term="架构设计" scheme="http://huaixuzhi.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代理简介</title>
    <link href="http://huaixuzhi.github.io/2017/12/22/agent-introduction/"/>
    <id>http://huaixuzhi.github.io/2017/12/22/agent-introduction/</id>
    <published>2017-12-22T02:20:17.000Z</published>
    <updated>2018-03-07T06:10:37.683Z</updated>
    
    <content type="html"><![CDATA[<p>正向代理，代理的是客户端；反向代理，代理的是服务器。<br><a id="more"></a></p><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>　　是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。<br>　　简而言之，客户端如果不能访问某个网站，但是可以访问一个代理服务器，而代理服务器可以访问那个客户端不能访问的网站。于是，客户端先连接代理服务器，告知要访问的网站地址，然后代理服务器获取网站内容，返回给客户端。<br>　　正向代理最典型的用途是为防火墙内局域网的客户端提供访问Internet的途径。</p><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>　　1. A无法访问B，通过代理可以进行访问，翻越GFW；<br>　　2. Cache作用；<br>　　3. 隐藏访问者A的行踪，B只会记录代理服务器的访问记录。<br>　　<img src="/2017/12/22/agent-introduction/agent-1.png"></p><h3 id="常用软件："><a href="#常用软件：" class="headerlink" title="常用软件："></a>常用软件：</h3><p>　　Nginx、Squid</p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><p>　　反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端。<br>　　和正向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。</p><h3 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h3><p>　　1. 保护和隐匿原始服务器；<br>　　2. 负载均衡。<br> 　　<img src="/2017/12/22/agent-introduction/agent-2.png"></p><h3 id="常用软件：-1"><a href="#常用软件：-1" class="headerlink" title="常用软件："></a>常用软件：</h3><p>　　Ngnix、Apache、LVS</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正向代理，代理的是客户端；反向代理，代理的是服务器。&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://huaixuzhi.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="基础知识" scheme="http://huaixuzhi.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="架构" scheme="http://huaixuzhi.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>求m的n次幂</title>
    <link href="http://huaixuzhi.github.io/2017/10/30/n-power-of-m/"/>
    <id>http://huaixuzhi.github.io/2017/10/30/n-power-of-m/</id>
    <published>2017-10-30T07:58:46.000Z</published>
    <updated>2018-03-07T06:10:37.683Z</updated>
    
    <content type="html"><![CDATA[<p>碰到这么个小问题，不考虑输入为负，不考虑输出越界的情况下，求m的n次幂m^n。<br><b>1·最基本的算法，可以使用循环来搞定，时间复杂度为O(n)：</b><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> pow(<span class="built_in">int</span> m,unsigned <span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="literal">result</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">result</span> *= m;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>2·接着考虑，如果先计算出m²，求m^n的话，只需要循环(n/2+1)次：</b><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> pow(<span class="built_in">int</span> m, unsigned <span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="literal">result</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> tmp = m * m; </span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="literal">result</span> *= tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span>)</span><br><span class="line">        <span class="literal">result</span> *= m; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><b>3·明显，如果先计算出m^4的话，时间复杂度会进一步降低，改进版代码如下，时间复杂度为O(log2n)：</b><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> pow(<span class="built_in">int</span> m, unsigned <span class="built_in">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="literal">result</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int</span> tmp = m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) </span><br><span class="line">            <span class="literal">result</span> *= tmp;</span><br><span class="line">        tmp *= tmp;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用递归的方式实现以上代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> square_root = <span class="built_in">pow</span>(m, n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> result = square_root * square_root;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">        result *= m;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>认知和思索，来源于生活的点点滴滴。</p>]]></content>
    
    <summary type="html">
    
      m的n次幂，关于基础代码的优化
    
    </summary>
    
      <category term="杂谈" scheme="http://huaixuzhi.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="面试" scheme="http://huaixuzhi.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="C语言" scheme="http://huaixuzhi.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>音视频压缩基础</title>
    <link href="http://huaixuzhi.github.io/2017/10/19/audio-vedio-compression-fundation/"/>
    <id>http://huaixuzhi.github.io/2017/10/19/audio-vedio-compression-fundation/</id>
    <published>2017-10-19T06:29:27.000Z</published>
    <updated>2018-03-07T06:10:37.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要压缩"><a href="#为什么要压缩" class="headerlink" title="为什么要压缩"></a>为什么要压缩</h2><p>　　数字化的图像和声音信号数据非常的庞大，例如一副640x480像素中等分辨率的彩色图像，使用RGB24（24bit/pixel）的数据量约为7.37Mbit/fps，如果是运动图像，以每秒30fps的速度播放，则视频传输速率为220Mbit/s，VCD的容量为650MB，所以对于未压缩的视频流来说，一张VCD只能存储23秒左右的视频。<br>　　视频传输速率：640 x 480 x 24 x 30 = 220Mbit/s<br>　　每帧的大小：640 x 480 x 24 = 7.37Mbit<br>　　分辨率：640 x 480<br>　　综上，视频压缩的目的就是为了减少视频存储的空间或者视频传输的带宽。</p><h2 id="为什么可以压缩"><a href="#为什么可以压缩" class="headerlink" title="为什么可以压缩"></a>为什么可以压缩</h2><p>　　任何压缩机制的目的都是除去数据中存在的相关性（或冗余）：<br>　　• 空间冗余：图像相邻像素之间有较强的相关性，可以根据图像中某一点的像素值推断出其相邻点的像素值；<br>　　　　帧内编码，方式是 预测，变换，量化和熵编码。<br>　　• 时间冗余：视频序列的相邻图像之间内容相似，在时间上相邻两帧图像的大部分像素的值变化很小；<br>　　　　帧间编码(I帧，P帧，B帧)，方式是运动估计，运动补偿，变换，量化，熵编码。<br>　　• 编码冗余：不同像素值出现的概率不同；<br>　　• 视觉冗余：人的视觉系统对某些细节不敏感；<br>　　• 知识冗余：规律性的结构可由先验知识和背景知识得到。<br>　　空间冗余编码，也被称为帧内压缩。一帧图像内的任何一个场景都是由若干像素点构成的，因此一个像素通常与它周围的某些像素在亮度和色度上存在一定的关系，在同一副图像中，规则物体和规则背景的表面物理特性具有相关性。这些相关性的光成像结果在数字化图像中就表现为数据的空间冗余。在存储这幅图像时，就没有必要去存储图像中每一点颜色的数据，可以用一种代码来记录。这样就可以记录下图像的特征，重现画面。</p><h2 id="数据压缩分类"><a href="#数据压缩分类" class="headerlink" title="数据压缩分类"></a>数据压缩分类</h2><h3 id="无损压缩（Lossless）"><a href="#无损压缩（Lossless）" class="headerlink" title="无损压缩（Lossless）"></a>无损压缩（Lossless）</h3><p>　　压缩前解压缩后图像完全一致X=X’<br>　　压缩比低(2:1~3:1)<br>　　例如：Winzip，JPEG-LS<br>　　　• 行程编码(Run-Length)<br>　　　• Huffman编码压缩 – 是一种长度不均匀的、平均码率可以接近信息源熵值的一种编码。该编码对于出现概率大的信息采用短字长码，出现频率小的信号使用长字长的码，已达到缩短平均码长，从而实现数据的压缩目的。<br>　　　• 字典压缩方法<br>　　　• 算术压缩方法</p><h3 id="有损压缩（Lossy）"><a href="#有损压缩（Lossy）" class="headerlink" title="有损压缩（Lossy）"></a>有损压缩（Lossy）</h3><p>　　压缩前解压缩后图像不一致X≠X’<br>　　压缩比高(10:1~20:1)<br>　　利用人的视觉系统的特性<br>　　例如：MPEG-2，H.264/AVC，AVS<br>　　　• 预测编码<br>　　　• 变换编码<br>　　　• 金字塔编码<br>　　　• 子带编码<br>　　　• 矢量量化编码<br>　　　• 图像压缩的国际标准</p>]]></content>
    
    <summary type="html">
    
      在不压缩的情况下，一个2小时的1080P的电影大小为1280 x 1080 x 24 x 30 x 7200 = 6.5T
    
    </summary>
    
      <category term="流媒体" scheme="http://huaixuzhi.github.io/categories/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    
      <category term="流媒体" scheme="http://huaixuzhi.github.io/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
      <category term="音视频" scheme="http://huaixuzhi.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频名词解释</title>
    <link href="http://huaixuzhi.github.io/2017/10/09/code-frame-rate-custom/"/>
    <id>http://huaixuzhi.github.io/2017/10/09/code-frame-rate-custom/</id>
    <published>2017-10-09T06:26:53.000Z</published>
    <updated>2018-03-07T06:10:37.653Z</updated>
    
    <content type="html"><![CDATA[<p><b><br>　　当网络带宽发生变化或受限制情况下，保证画面质量和流畅性可以分为三类:</b><font color="red"><br>　　（1）画面质量优先（保证帧率）<br>　　（2）画面流畅性优先 （保证码率）</font><br>　　（3）画面质量和流畅性兼顾</p><h2 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h2><p>　　每秒从连续信号中提取并组成离散信号的采样个数，用Hz来表示。通俗点说，<font color="#FF0000">就是计算机每秒采集多少个信号样本。</font></p><h2 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h2><p>　　数据传输时单位时间传送的数据位数，一般用的单位是kbps即千位每秒。 <font color="red"><br>　　码率=采样率 x 位深度 x 声道 （例如： 某文件码率=44.1Khz x 16位 x 2声道 = 1411.2Kbps）<br>　　文件大小=码率 x 时长 </font><br>　　单位时间内取样率越大，精度就越高，处理出来的文件就越接近原始文件，但是文件体积与取样率是成正比的，所以几乎所有的编码格式重视的都是如何用最低的码率达到最少的失真，围绕这个核心衍生出来cbr（固定码率）与vbr（可变码率）， “码率”就是失真度，码率越高越清晰，反之则画面粗糙而多马赛克。举例来看，对于一个音频，其码率越高，被压缩的比例越小，音质损失越小，与音源的音质越接近。</p><h2 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h2><p>　　1S的时间内显示的图片的帧数，可以理解为图形处理器每秒能刷新几次。<br>　　帧率越大，画面越流畅；帧率越小，画面越有跳动感。由于人眼的特殊生理结构，如果看到的画面帧率高于16的时候，就会认为是连贯的。</p><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><p>　　（矩形）图片的长度和宽度，即图片尺寸。</p><h2 id="视频编码的基本原理："><a href="#视频编码的基本原理：" class="headerlink" title="视频编码的基本原理："></a>视频编码的基本原理：</h2><p>　　视频图像数据有极强的相关性，也就是说有大量的冗余信息。其中冗余信息可分为空域冗余信息和时域冗余信息。压缩技术就是将数据中的冗余信息去掉（去除数据之间的相关性），压缩技术包含帧内图像数据压缩技术、帧间图像数据压缩技术和熵编码压缩技术。</p><h2 id="分辨率：CIF-D1-720P-1080P"><a href="#分辨率：CIF-D1-720P-1080P" class="headerlink" title="分辨率：CIF  D1 720P 1080P"></a>分辨率：CIF  D1 720P 1080P</h2><p><b>CIF</b>：标准化图像格式（Common Intermediate Format），320 x 288像素；<br><b>D1</b>：数字电视系统显示格式标准，720 x 575像素；<br><b>720P</b>：1280 x 720像素；<br><b>1080P</b>：1920 x 1080像素。</p><p>&lt;P：即ppi，像素每英寸&gt;</p><h2 id="I帧P帧B帧："><a href="#I帧P帧B帧：" class="headerlink" title="I帧P帧B帧："></a>I帧P帧B帧：</h2><p>&lt;在视频压缩中，每帧代表一幅静止的图像，而在实际压缩中，会采取各种算法减少数据的容量，其中IPB是最常见的&gt;<br>　　<font color="red">I帧是关键帧，属于帧内压缩；P帧是向前搜索；B是双向搜索，都是基于I帧来压缩数据的。</font><br>　　<b>I帧</b>表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）。<br>　　<b>P帧</b>表示这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要应用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）<br>　　<b>B帧</b>是双向差别帧，也就是B帧记录的是本帧与前后帧的差别（具体比较复杂，有4种情况），换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累~。<br>　　从上面的解释看，我们知道I和P的解码算法比较简单，资源占用也比较少，I只要自己完成就行了，P呢，也只需要解码器把前一个画面缓存一下，遇到P时就使用之前缓存的画面就好了，如果视频流只有I和P，解码器可以不管后面的数据，边读边解码，线性前进，大家很舒服。<br>　　但网络上的电影很多都采用了B帧，因为B帧记录的是前后帧的差别，比P帧能节约更多的空间，但这样一来，文件小了，解码器就麻烦了，因为在解码时，不仅要用之前缓存的画面，还要知道下一个I或者P的画面（也就是说要预读预解码），而且，B帧不能简单地丢掉，因为B帧其实也包含了画面信息，如果简单丢掉，并用之前的画面简单重复，就会造成画面卡（其实就是丢帧了），并且由于网络上的电影为了节约空间，往往使用相当多的B帧，B帧用的多，对不支持B帧的播放器就造成更大的困扰，画面也就越卡。<br>　　一般平均来说，I的压缩率是7（跟JPG差不多），P是20，B可以达到50，可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。</p>]]></content>
    
    <summary type="html">
    
      帧率；码率；采样率；视频编码的基本原理：I帧P帧B帧
    
    </summary>
    
      <category term="流媒体" scheme="http://huaixuzhi.github.io/categories/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
    
      <category term="流媒体" scheme="http://huaixuzhi.github.io/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
      <category term="音视频" scheme="http://huaixuzhi.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>查看history中输入量前三的命令</title>
    <link href="http://huaixuzhi.github.io/2017/09/14/search-high-frequency-history/"/>
    <id>http://huaixuzhi.github.io/2017/09/14/search-high-frequency-history/</id>
    <published>2017-09-14T06:44:46.000Z</published>
    <updated>2018-03-07T06:10:37.671Z</updated>
    
    <content type="html"><![CDATA[<p>2X问了个问题，如何查找history中前n个出现频率最高的命令？<br><a id="more"></a><br>答案如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.bash_history | sort | uniq -c | sort -k1r | head -n 3</span><br></pre></td></tr></table></figure></p><p>bash_history内所有命令（行）按照首字母排序 | 去除重复行，在行首位置输出该行重复的次数 | 按照第一个域进行逆序排序 | 列出起始三行</p><h3 id="关于sort的几个参数："><a href="#关于sort的几个参数：" class="headerlink" title="关于sort的几个参数："></a>关于sort的几个参数：</h3><p>sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。<br>-r – 将排序方式改为降序；<br>-k – 指定排序的列数，如-k2表示按第二列进行排序，-k2.2表示按照第二列的第二个字母进行排序；<br>-t – 如果列与列之间由分隔符（如: ; |等）隔开，此参数用于指定分隔符，如-t : ;<br>-n – 以数值进行排序；<br>-u – 排序输出中去除重复行；</p><h3 id="关于uniq的几个参数："><a href="#关于uniq的几个参数：" class="headerlink" title="关于uniq的几个参数："></a>关于uniq的几个参数：</h3><p>uniq命令可以去除排序过的文件中的重复行，因此uniq经常和sort合用。（也就是说，为了使uniq起作用，所有的重复行必须是相邻的）<br>-c – 删除重复行，同时在行首位置输出该行重复字数；<br>-d – 仅显示重复的行；<br>-u – 仅显示不重复的行；</p><p><a href="https://wx.qq.com/cgi-bin/mmwebwx-bin/webwxgetmsgimg?&amp;MsgID=1409926881425837056&amp;skey=%40crypt_fdb69c85_f898c4339428fc9a9ed82b5d3169aa78" target="_blank" rel="noopener">https://wx.qq.com/cgi-bin/mmwebwx-bin/webwxgetmsgimg?&amp;MsgID=1409926881425837056&amp;skey=%40crypt_fdb69c85_f898c4339428fc9a9ed82b5d3169aa78</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2X问了个问题，如何查找history中前n个出现频率最高的命令？&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://huaixuzhi.github.io/categories/Linux/"/>
    
    
      <category term="Shell" scheme="http://huaixuzhi.github.io/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>使用数组简化数据结构</title>
    <link href="http://huaixuzhi.github.io/2017/06/15/get-program-from-data/"/>
    <id>http://huaixuzhi.github.io/2017/06/15/get-program-from-data/</id>
    <published>2017-06-15T09:34:53.000Z</published>
    <updated>2018-03-07T06:10:37.650Z</updated>
    
    <content type="html"><![CDATA[<h3 id="从数据中得出程序的结构"><a href="#从数据中得出程序的结构" class="headerlink" title="从数据中得出程序的结构"></a>从数据中得出程序的结构</h3><p>　　程序员在节省空间方面无计可施时，将自己从代码中解脱出来，退回起点并集中精力研究数据，常常能有奇效。数据的表示形式，是程序设计的根本。<br>　　<strong>使用数组重新编写重复代码：</strong>冗长的<strong>相似</strong>代码常常可以使用最简单的数据结构–数组来更好的表述；<br>　　<strong>封装复杂结构：</strong>当需要非常复杂的数据结构时，使用抽象术语进行定义，并将操作表示为类；<br>　　<strong>尽可能使用高级工具：</strong>超文本，k-v，电子表格，数据库等，特定问题，特定方案。</p><h4 id="简单的示例："><a href="#简单的示例：" class="headerlink" title="简单的示例："></a>简单的示例：</h4><p>　　某个程序，用户可以通过点击菜单来实现八个选项中的选择（八选一）。<br>　　<strong>常见代码</strong>，此时的代码是合理的，但是充满了重复和无聊，大概需要100行代码来实现这个功能。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menuitem0_click</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">menuitem0.checked = <span class="number">1</span>;</span><br><span class="line">menuitem1.checked = <span class="number">0</span>;</span><br><span class="line">menuitem2.checked = <span class="number">0</span>;</span><br><span class="line">menuitem3.checked = <span class="number">0</span>;</span><br><span class="line">menuitem4.checked = <span class="number">0</span>;</span><br><span class="line">menuitem5.checked = <span class="number">0</span>;</span><br><span class="line">menuitem6.checked = <span class="number">0</span>;</span><br><span class="line">menuitem7.checked = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menuitem1_click</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">menuitem0.checked = <span class="number">0</span>;</span><br><span class="line">menuitem1.checked = <span class="number">1</span>;</span><br><span class="line">menuitem2.checked = <span class="number">0</span>;</span><br><span class="line">menuitem3.checked = <span class="number">0</span>;</span><br><span class="line">menuitem4.checked = <span class="number">0</span>;</span><br><span class="line">menuitem5.checked = <span class="number">0</span>;</span><br><span class="line">menuitem6.checked = <span class="number">0</span>;</span><br><span class="line">menuitem7.checked = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></p><p>　　<strong>将大部分重复代码转换为一个uncheckall函数</strong>，该函数将每个checked字段置为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menuitem0_click</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uncheckall();</span><br><span class="line">menuitem0.checked = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">menuitem1_click</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uncheckall();</span><br><span class="line">menuitem1.checked = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>　　<strong>但代码中还有七个函数相似，使用数组进行替换</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">menuitem_click</span><span class="params">(<span class="keyword">int</span> choice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uncheckall();</span><br><span class="line">menuitem[i].checked = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      程序员在节省空间方面无计可施时，将自己从代码中解脱出来，退回起点并集中精力研究数据，常常能有奇效。数据的表示形式，是程序设计的根本。
    
    </summary>
    
      <category term="Linux" scheme="http://huaixuzhi.github.io/categories/Linux/"/>
    
    
      <category term="读书笔记" scheme="http://huaixuzhi.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="代码优化" scheme="http://huaixuzhi.github.io/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>网站架构模式_读书笔记</title>
    <link href="http://huaixuzhi.github.io/2017/06/06/architecture-mode/"/>
    <id>http://huaixuzhi.github.io/2017/06/06/architecture-mode/</id>
    <published>2017-06-06T07:05:46.000Z</published>
    <updated>2018-03-07T06:10:37.680Z</updated>
    
    <content type="html"><![CDATA[<p>　　架构：最高层次的规划，难以改变的决定。<br><a id="more"></a></p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>　　将系统在横向维度上切分成几个部分，每个部分负责相对比较单一的职责，通过上层对下层的依赖和调用组成一个完整的系统。</p><ol><li>应用层：负责具体业务和视图展示，如网站首页及搜索输入和结果展示；</li><li>服务层：为应用层提供服务支持，如用户管理服务，购物车服务等；</li><li>数据层：提供数据存储访问服务，如数据库、缓存、文件、搜索引擎等。</li></ol><p><strong>分层禁忌</strong>：需要合理规划层次边界和接口，在开发过程中，严格遵循分层架构的约束，进制跨层次调用（应用层直接调用数据层）及逆向调用（数据层调用服务层，或服务层调用应用层）。</p><h3 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h3><p>　　将不同功能和服务分割，形成高内聚低耦合的模块。（一方面有助于软件的开发和维护；另一方面便于不同模块的分布式部署，提高网站的并发处理和功能扩展能力）。</p><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><p>　　分层和分割的一个主要目的即为了切分后的模块便于分布式部署，不同模块部署到不同服务器，通过网络调用协调工作。<br>分布式可以解决网站的高并发，但会带来其他的问题：</p><ol><li>分布式必须通过网络，会对性能造成比较严重的影响；</li><li>服务器增多，宕机概率也相应增大，会导致网站可用性降低；</li><li>数据在分布式环境中数据一致性问题；</li><li>分布式会导致网站依赖错综复杂，开发管理维护困难。</li></ol><p><strong>常用的分布式方案：</strong><br><strong>分布式应用和服务</strong>，分布式部署，可以提升网站性能和并发性、加快开发和发布速度、减少数据库连接资源消耗，提供不同应用复用共同服务，便于业务功能扩展；<br><strong>分布式静态资源</strong>，网站的静态资源如JS、CSS、Logo图片等资源独立分布式部署，并采用独立的域名，即人们常说的动静分离，静态资源分布式部署可以减轻应用服务器的负载压力；<br><strong>分布式数据和存储</strong>，大型网站需要处理P级数据，单台计算机无法提供这么大的存储空间，而且，为网站应用而生的各种NoSQL产品几乎都是分布式的；<br><strong>分布式计算</strong>，如Hadoop及MapReduce分布式计算框架。</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>　　使用分布式可以将分层和分割后的模块独立部署；对于用户访问集中的模块（如网站首页）可以将独立部署的服务器集群化，即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>　　缓存就是将数据存放在距离计算最近的位置以加快处理速度，缓存是改善软件性能的第一手段。<br>　　<strong>CDN：</strong>内容分发网络，如视频网站和门户网站会将用户访问量大的热点内容缓存在CDN；<br>　　<strong>反向代理：</strong>反向代理属于网站前端架构的一部分，部署在网站的前端，当用户请求到达网站的数据中心时，最先访问到的就是反向代理服务器，这里缓存网站的静态资源，无需将请求继续转发给应用服务器；<br>　　<strong>本地缓存：</strong>在应用服务器本地缓存着热点数据，应用程序可以在本地内存中直接访问数据，而无需访问数据库；<br>　　<strong>分布式缓存：</strong>将数据缓存在一个专门的分布式缓存集群中，应用程序通过网络通信访问缓存数据。<br>使用缓存有两个前提条件：数据访问热点不均衡；数据在某个时间段内有效，不会很快过期。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>　　计算机软件发展的一个重要目标和驱动力是降低软件耦合性。<br>　　大型网站架构中，系统解耦合的手段除了分层、分割、分布，另外一个重要手段就是异步。<br>在单一服务器内部，可以通过多线程共享内存队列的方式实现异步，即出处在业务操作前的线程将输入写入队列，后面的线程从队列中读取数据进行处理；在分布式系统中，多个服务器集群通过分布式消息队列实现异步（分布式消息队列可以看作内存队列的分布式部署）。<br>　　异步架构是典型的生产者消费者模式，两者不存在直接调用关系，主要保持数据结构不变，彼此功能实现可以随意变化而且不相互影响，这对网站扩展新功能非常便利。<br><strong>异步消息有如下特性：</strong><br>　　提高系统可用性；<br>　　加快网站响应速度；<br>　　消除并发访问高峰：网站访问是随机的，使用消息队列可以将突然增加的访问请求数据放入消息队列，等待消费者服务器依次处理，消除对网站负载的压力。</p><h3 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h3><p><strong>冷备份：</strong>数据库定期备份、存档；<br><strong>热备份：</strong>数据库主从分离。</p><h3 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h3><p>　　（当前自动化架构设计主要集中在发布运维方面）<br><strong>发布自动化：</strong>自动化代码管理；自动化测试；自动化安全监测；<br><strong>运维自动化：</strong>自动化监控；自动化报警；自动化失效转移；自动化失效恢复；自动化降级；自动化分配资源。</p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ol><li>通过密码和手机校验码进行身份认证；</li><li>登录、交易等操作对网络通信进行加密；</li><li>网站服务器上存储的敏感数据（如用户信息等）进行加密处理；</li><li>为防止机器人程序攻击网站，网站使用验证码进行识别；</li><li>对常见的XSS攻击、SQL注入攻击，需要进行编码转换等相应处理；</li><li>对垃圾信息、敏感信息进行过滤；</li><li>对转账等重要操作根据交易模型和交易信息进行风险控制。</li></ol><pre><code>摘自《大型网站技术架构》李智慧</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　架构：最高层次的规划，难以改变的决定。&lt;br&gt;
    
    </summary>
    
      <category term="架构" scheme="http://huaixuzhi.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="读书笔记" scheme="http://huaixuzhi.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="架构设计" scheme="http://huaixuzhi.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>网站架构演化发展历程_读书笔记</title>
    <link href="http://huaixuzhi.github.io/2017/05/23/architecture-evolution/"/>
    <id>http://huaixuzhi.github.io/2017/05/23/architecture-evolution/</id>
    <published>2017-05-23T11:43:22.000Z</published>
    <updated>2018-03-07T06:10:37.669Z</updated>
    
    <content type="html"><![CDATA[<h3 id="大型网站软件系统的特点"><a href="#大型网站软件系统的特点" class="headerlink" title="大型网站软件系统的特点"></a>大型网站软件系统的特点</h3><p>· 高并发，大流量<br>· 高可用：系统7x24小时不间断服务；<br>· 海量数据：需要存储、管理海量数据，需要使用大量服务器；<br>· 用户分布广泛，网络情况复杂；<br>· 安全环境恶劣；<br>· 需求快速变更，发布频繁；<br>· 渐进式发展。</p><h3 id="大型网站架构演化发展历"><a href="#大型网站架构演化发展历" class="headerlink" title="大型网站架构演化发展历"></a>大型网站架构演化发展历</h3><h4 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h4><p>　　应用程序、数据库、文件等所有的资源都在一台服务器上（Linux + PHP + Apache + MySQL +各种免费开源软件+廉价服务器）<br><img src="/2017/05/23/architecture-evolution/01.png"></p><h3 id="应用服务和数据服务分离"><a href="#应用服务和数据服务分离" class="headerlink" title="应用服务和数据服务分离"></a>应用服务和数据服务分离</h3><p>问题：越来越多的用户访问导致性能越来越差，越来越多的数据导致存储空间不足。<br>方案：应用和数据分离。<br>　　应用和数据分离后整个网站使用三台服务器：应用服务器、文件服务器、数据库服务器，这三台服务器对硬件资源的要求各不相同，应用服务器需要处理大量的业务逻辑，所以需要强大的CPU；数据库服务器需要快速磁盘检索和数据缓存，所以需要更快的硬盘和更大的内存；文件存储服务器需要存储用户大量的上传文件，所以需要更大的硬盘。<br><img src="/2017/05/23/architecture-evolution/02.png"></p><h4 id="使用缓存改善网站性能"><a href="#使用缓存改善网站性能" class="headerlink" title="使用缓存改善网站性能"></a>使用缓存改善网站性能</h4><p>问题：网站访问特点和现实世界的财富分配一样，遵循二八定律，即80%的业务访问集中在20%的数据上。<br>方案：将访问集中的20%数据缓存在内存中，可以减少数据库访问压力，提高网站数据访问速度。<br>　　网站使用的缓存可以分为两种：<br>　　本地缓存（缓存在应用服务器上），访问速度快，但受到应用服务器内存限制，其缓存数量有限，而且会出现和应用程序争用内存的情况；<br>　　远程缓存（缓存在专门的分布式缓存服务器上），一般采用大内存服务器做集群，在理论上做到不受内存容量限制。<br><img src="/2017/05/23/architecture-evolution/03.png"></p><h4 id="使用应用服务器集群改善网站的并发处理能力"><a href="#使用应用服务器集群改善网站的并发处理能力" class="headerlink" title="使用应用服务器集群改善网站的并发处理能力"></a>使用应用服务器集群改善网站的并发处理能力</h4><p>问题：缓存可以有效缓解数据库访问压力，但是单一应用服务器能够处理的请求连接是有限的，在网站访问高峰期，应用服务器会成为整个网站的瓶颈。<br>方案：应用服务器集群。<br>　　通过负载均衡调度服务器，可将来自用户浏览器的访问请求分发到应用服务器集群中的任何一台服务器上。<br><img src="/2017/05/23/architecture-evolution/04.png"></p><h4 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h4><p>问题：虽然使用缓存后，绝大部分的数据读操作访问可以不通过数据库就能完成，但是仍有一部分读操作（缓存访问不命中、缓存过期）和全部的写操作需要访问数据库，在网站用户达到一定的规模后，数据库会因为负载压力过高成为瓶颈。<br>方案：数据库读写分离。<br><img src="/2017/05/23/architecture-evolution/05.png"></p><h4 id="使用反向代理和CDN加速网站响应"><a href="#使用反向代理和CDN加速网站响应" class="headerlink" title="使用反向代理和CDN加速网站响应"></a>使用反向代理和CDN加速网站响应</h4><p>问题：不同地区用户访问网站时速度差别较大。<br>方案：CDN和反向代理。<br><img src="/2017/05/23/architecture-evolution/06.png"></p><h3 id="使用分布式文件系统和分布式数据库系统"><a href="#使用分布式文件系统和分布式数据库系统" class="headerlink" title="使用分布式文件系统和分布式数据库系统"></a>使用分布式文件系统和分布式数据库系统</h3><img src="/2017/05/23/architecture-evolution/07.png"><h4 id="使用NoSQL和搜索引擎"><a href="#使用NoSQL和搜索引擎" class="headerlink" title="使用NoSQL和搜索引擎"></a>使用NoSQL和搜索引擎</h4><p>　　随着网站业务的复杂化，对数据存储和检索的需求也越来越复杂，网站需要采用一些非关系数据库技术如NoSQL和非数据库查询技术如搜索引擎。<br><img src="/2017/05/23/architecture-evolution/08.png"></p><h4 id="业务拆分"><a href="#业务拆分" class="headerlink" title="业务拆分"></a>业务拆分</h4><p>　　大型网站为了应对日益复杂的业务场景，通常会将整个网站业务分成不同的产品线，如大型购物交易网站会将首页、商铺、订单、卖家、买家等拆分成不同产品线，归不同的业务团队负责，每个应用独立部署运维，应用之间可以通过一个超链接建立关系（如首页上的导航链接每个都指向不同的应用地址），也可以通过消息队列进行数据分发，还可以通过访问同一个数据存储系统来构成一个关联的完整系统。<br><img src="/2017/05/23/architecture-evolution/09.png"></p><pre><code>摘自《大型网站技术架构》李智慧</code></pre>]]></content>
    
    <summary type="html">
    
      高并发，大流量；,高可用：系统7x24小时不间断服务；,海量数据：需要存储、管理海量数据，需要使用大量服务器；,用户分布广泛，网络情况复杂；,安全环境恶劣；,需求快速变更，发布频繁；,渐进式发展。
    
    </summary>
    
      <category term="架构" scheme="http://huaixuzhi.github.io/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="读书笔记" scheme="http://huaixuzhi.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="架构设计" scheme="http://huaixuzhi.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redmine导入测试用例(基于Windows环境)</title>
    <link href="http://huaixuzhi.github.io/2017/05/03/Excel-import-into-Redmine/"/>
    <id>http://huaixuzhi.github.io/2017/05/03/Excel-import-into-Redmine/</id>
    <published>2017-05-03T06:53:20.000Z</published>
    <updated>2018-03-07T06:10:37.649Z</updated>
    
    <content type="html"><![CDATA[<p>项目中需要将原有的缺陷导入到Redmine中统一管理，但是Redmine原工程中是不支持Excel导入的，需要安装插件来实现此功能。<br><a id="more"></a></p><h3 id="Redmine插件下载及安装"><a href="#Redmine插件下载及安装" class="headerlink" title="Redmine插件下载及安装"></a>Redmine插件下载及安装</h3><ol><li>下载Redmine导入插件，<a href="https://github.com/zh/redmine_importer" target="_blank" rel="noopener">https://github.com/zh/redmine_importer</a></li><li>解压到Redmine安装目录下的plugins目录，(如E:\install\redmine-2.6.2\plugins)，并改名为redmine_importer。<br>(Bitnami Redmine的解压目录：E:\install\Bitnami\redmine-2.6.2-0\apps\redmine\htdocs\plugins)</li></ol><h3 id="Redmine安装CSV支持"><a href="#Redmine安装CSV支持" class="headerlink" title="Redmine安装CSV支持"></a>Redmine安装CSV支持</h3><ol><li>下载CSV包，<a href="https://rubygems.org/gems/fastercsv/versions/1.5.5" target="_blank" rel="noopener">https://rubygems.org/gems/fastercsv/versions/1.5.5</a> ，如’fastercsv-1.5.1.gem’</li><li><p>将包放到Redmine安装目录，如E:\install\Bitnami下(或任意目录，放到安装目录只是为了好找)，运行</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:<span class="symbol">\i</span>nstall<span class="symbol">\B</span>itnami<span class="symbol">\r</span>edmine-2.6.2<span class="symbol">\u</span>se_redmine.bat</span><br></pre></td></tr></table></figure></li><li><p>在打开的命令行切换到fastercsv包所在目录，然后执行命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="keyword">install</span> fastercsv</span><br></pre></td></tr></table></figure></li><li><p>更新Redmine插件</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd E:<span class="symbol">\i</span>nstall<span class="symbol">\B</span>itnami<span class="symbol">\r</span>edmine-2.6.2<span class="symbol">\a</span>pps<span class="symbol">\r</span>edmine<span class="symbol">\h</span>tdocs<span class="symbol">\p</span>lugins</span><br><span class="line">bundle exec rake redmine:plugins:migrate RAILS_ENV=production</span><br></pre></td></tr></table></figure></li></ol><h3 id="Redmine配置"><a href="#Redmine配置" class="headerlink" title="Redmine配置"></a>Redmine配置</h3><ol><li>重启Redmine</li><li><p>在项目-&gt;配置-&gt;模块中，勾选Importer，点击保存</p> <img src="/2017/05/03/Excel-import-into-Redmine/csv-import-into-redmine-01.jpg" title="添加Importer"></li></ol><h3 id="导入CSV格式"><a href="#导入CSV格式" class="headerlink" title="导入CSV格式"></a>导入CSV格式</h3><ol><li><p>导入文件选择</p> <img src="/2017/05/03/Excel-import-into-Redmine/csv-import-into-redmine-02.jpg" title="请不要在csv文件中直接编辑，我们要新建一个excel，在excel中整理完之后，将excel另存为csv格式。"></li><li><p>导入规则制定</p><img src="/2017/05/03/Excel-import-into-Redmine/csv-import-into-redmine-03.jpg" title="导入时需要注意的是，在csv中，为空的列，我们应该在“字段配对”中，相应的选择忽略。"></li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li><p>导入时出现问题：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BUG <span class="keyword">Table</span> 'bitnami_redmine.import_in_progresses' doesn't <span class="comment">exist</span></span><br></pre></td></tr></table></figure><p> 因为未更新Redmine插件，正确执行6.后就没问题了。</p></li><li>csv格式应该为utf-8编码格式。</li></ol><p>参考网址：<br><a href="http://www.redmine.org.cn/338.html" target="_blank" rel="noopener">http://www.redmine.org.cn/338.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中需要将原有的缺陷导入到Redmine中统一管理，但是Redmine原工程中是不支持Excel导入的，需要安装插件来实现此功能。&lt;br&gt;
    
    </summary>
    
      <category term="测试" scheme="http://huaixuzhi.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="http://huaixuzhi.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="ruby" scheme="http://huaixuzhi.github.io/tags/ruby/"/>
    
  </entry>
  
</feed>
