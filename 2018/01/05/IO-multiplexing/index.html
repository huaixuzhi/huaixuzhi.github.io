<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>I/O复用函数比较(select/poll/epoll) | 纸上得来</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">I/O复用函数比较(select/poll/epoll)</h1><a id="logo" href="/.">纸上得来</a><p class="description">酒盏酌来须满满，花枝看即落纷纷。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">I/O复用函数比较(select/poll/epoll)</h1><div class="post-meta">Jan 5, 2018<span> | </span><span class="category"><a href="/categories/网络/">网络</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一。系统函数"><span class="toc-number">1.</span> <span class="toc-text">一。系统函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-int-epoll-create-int-size"><span class="toc-number">1.1.</span> <span class="toc-text">1. int epoll_create(int size);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event"><span class="toc-number">1.2.</span> <span class="toc-text">2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><span class="toc-number">1.3.</span> <span class="toc-text">3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二。epoll实现原理"><span class="toc-number">2.</span> <span class="toc-text">二。epoll实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三。LT和ET模式"><span class="toc-number">3.</span> <span class="toc-text">三。LT和ET模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四。select、poll、epoll三组I-O复用函数比较"><span class="toc-number">4.</span> <span class="toc-text">四。select、poll、epoll三组I/O复用函数比较</span></a></li></ol></div></div><div class="post-content"><h3 id="一。系统函数"><a href="#一。系统函数" class="headerlink" title="一。系统函数"></a>一。系统函数</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>epoll的接口非常简单，一共就三个函数：</p>
<h4 id="1-int-epoll-create-int-size"><a href="#1-int-epoll-create-int-size" class="headerlink" title="1. int epoll_create(int size);"></a>1. int epoll_create(int size);</h4><p>　　创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大。这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<h4 id="2-int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event"><a href="#2-int-epoll-ctl-int-epfd-int-op-int-fd-struct-epoll-event-event" class="headerlink" title="2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);"></a>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</h4><p>　　epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：<br>　　EPOLL_CTL_ADD：注册新的fd到epfd中；<br>　　EPOLL_CTL_MOD：修改已经注册的fd的监听事件；<br>　　EPOLL_CTL_DEL：从epfd中删除一个fd；<br>第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事件，struct epoll_event结构如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>events可以是以下几个宏的集合：<br>　　EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<br>　　EPOLLOUT：表示对应的文件描述符可以写；<br>　　EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br>　　EPOLLERR：表示对应的文件描述符发生错误；<br>　　EPOLLHUP：表示对应的文件描述符被挂断；<br>　　EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<br>　　EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>
<h4 id="3-int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout"><a href="#3-int-epoll-wait-int-epfd-struct-epoll-event-events-int-maxevents-int-timeout" class="headerlink" title="3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);"></a>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</h4><p>　　等待事件的产生，参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。<br>//epoll_wait范围之后应该是一个循环，遍利所有的事件：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">n</span> = 0; <span class="keyword">n</span> &lt; nfds; ++<span class="keyword">n</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果是主socket的事件的话，则表示有新连接进入了，进行新连接的处理</span></span><br><span class="line">    <span class="keyword">if</span>(events[<span class="keyword">n</span>].data.fd == listener) </span><br><span class="line">    &#123;</span><br><span class="line">       client = accept(listener, (struct sockaddr *) &amp;<span class="keyword">local</span>,  &amp;addrlen);</span><br><span class="line">       <span class="keyword">if</span>(client &lt; 0)</span><br><span class="line">       &#123;</span><br><span class="line">           perror(<span class="string">"accept"</span>);</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将新连接置于非阻塞模式</span></span><br><span class="line">       setnonblocking(client); </span><br><span class="line">       <span class="comment">//并且将新连接也加入EPOLL的监听队列。</span></span><br><span class="line">       <span class="comment">//注意，这里的参数EPOLLIN | EPOLLET并没有设置对写socket的监听，</span></span><br><span class="line">       <span class="comment">//如果有写操作的话，这个时候epoll是不会返回事件的，</span></span><br><span class="line">       <span class="comment">//如果要对写操作也监听的话，应该是EPOLLIN | EPOLLOUT | EPOLLET</span></span><br><span class="line">       ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">       ev.data.fd = client;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//设置好event之后，将这个新的event通过epoll_ctl,加入到epoll的监听队列里面，</span></span><br><span class="line">       <span class="comment">//这里用EPOLL_CTL_ADD 来加一个新的 epoll事件，通过EPOLL_CTL_DEL来减少一个epoll事件，</span></span><br><span class="line">       <span class="comment">//通过EPOLL_CTL_MOD来改变一个事件的监听方式。</span></span><br><span class="line">       <span class="keyword">if</span> (epoll_ctl(kdpfd, EPOLL_CTL_ADD, client, &amp;ev) &lt; 0) </span><br><span class="line">       &#123;  </span><br><span class="line">           fprintf(stderr, "epoll <span class="keyword">set</span> insertion <span class="keyword">error</span>: fd=%d0, client);</span><br><span class="line">           <span class="keyword">return</span> -1;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 如果不是主socket的事件的话，则代表是一个用户socket的事件</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//则来处理这个用户socket的事情，比如说read(fd,xxx)之类的，或者一些其他的处理</span></span><br><span class="line">        do_use_fd(events[<span class="keyword">n</span>].data.fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><b>实例使用：</b><br>EPOLL模型似乎只有一种格式<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">TRUE</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//等待EPOLL时间的发生，相当于监听</span></span><br><span class="line">  <span class="keyword">int</span> nfds = epoll_wait (m_epoll_fd, m_events, MAX_EVENTS, EPOLL_TIME_OUT); </span><br><span class="line">  <span class="keyword">if</span> (nfds &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  m_bOnTimeChecking = <span class="keyword">FALSE</span>;</span><br><span class="line">  G_CurTime = time(<span class="keyword">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nfds; i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//如果新监测到一个SOCKET用户连接到了绑定的SOCKET端口，建立新的连接。</span></span><br><span class="line">       <span class="keyword">if</span> (m_events[i].data.fd == m_listen_sock_fd)        &#123;</span><br><span class="line">          OnAcceptSockEpoll ();</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="comment">//如果是已经连接的用户，并且收到数据，那么进行读入。</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (m_events[i].events &amp; EPOLLIN) </span><br><span class="line">       &#123;</span><br><span class="line">          OnReadEpoll (i);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//查看当前的活动连接是否有需要写出的数据。</span></span><br><span class="line">       OnWriteEpoll (i); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">int</span>) </span><br><span class="line">    &#123;</span><br><span class="line">      PRINTF (<span class="string">"CATCH捕获错误/n"</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  m_bOnTimeChecking = <span class="keyword">TRUE</span>;</span><br><span class="line">  <span class="comment">//进行一些定时的操作，主要就是删除一些短线用户等</span></span><br><span class="line">  OnTimer ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Epoll模型主要负责对大量并发用户的请求进行及时处理，完成服务器与客户端的数据交互。其具体的实现步骤如下：<br>(a) 使用epoll_create()函数创建文件描述，设定将可管理的最大socket描述符数目。<br>(b) 创建与epoll关联的接收线程，应用程序可以创建多个接收线程来处理epoll上的读通知事件，线程的数量依赖于程序的具体需要。<br>(c) 创建一个侦听socket描述符ListenSock；将该描述符设定为非阻塞模式，调用Listen（）函数在套接字上侦听有无新的连接请求，在epoll_event结构中设置要处理的事件类型EPOLLIN，工作方式为 epoll_ET，以提高工作效率，同时使用epoll_ctl()注册事件，最后启动网络监视线程。<br>(d) 网络监视线程启动循环，epoll_wait()等待epoll事件发生。<br>(e) 如果epoll事件表明有新的连接请求，则调用accept（）函数，将用户socket描述符添加到epoll_data联合体，同时设定该描述符为非阻塞，并在epoll_event结构中设置要处理的事件类型为读和写，工作方式为epoll_ET.<br>(f) 如果epoll事件表明socket描述符上有数据可读，则将该socket描述符加入可读队列，通知接收线程读入数据，并将接收到的数据放入到接收数据的链表中，经逻辑处理后，将反馈的数据包放入到发送数据链表中，等待由发送线程发送。</p>
<h3 id="二。epoll实现原理"><a href="#二。epoll实现原理" class="headerlink" title="二。epoll实现原理"></a>二。epoll实现原理</h3><p>　　select和poll在每次调用时，都会把监控的所有socket传递给系统，也就是说，需要将用户态的socket列表拷贝到内核态（如果是数以万计的句柄会导致每次要拷贝几十到几百KB的内存到内核态）。<br>　　epoll在调用epoll_create时，向内核注册一个文件系统，并创建file结点。epoll在被内核初始化时，会开辟内核高速缓冲区，用于放置我们需要监控的socket（epoll_ctl传入），这些socket会以红黑树的形式保存在内核缓存中，支持查找、插入、删除操作；同时会建立一个list表，用于存储准备就绪的事件，当epoll_wait调用时，仅需要观察这个list链表中是否有数据即可，有数据就返回，没数据就sleep了。<br>　　epoll的准备就绪list链表如何维护？在执行epoll_ctl时，除了把socket放到epoll文件系统epfd对应的红黑树之外，还会给内核中断处理程序注册一个回调函数，如果此句柄的中断到达，则将其放入准备就绪的list链表中。<br><b>总结epoll的处理：</b><br>　　执行epoll_create时，创建了红黑树和就绪链表，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。</p>
<h3 id="三。LT和ET模式"><a href="#三。LT和ET模式" class="headerlink" title="三。LT和ET模式"></a>三。LT和ET模式</h3><p><b>LT（Level Triggered，水平触发）</b><br>　　效率会低于ET触发，尤其在大并发，大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况。<br><b>ET（Edge Triggered，边沿触发）</b><br>　　效率非常高，在并发，大流量的情况下，会比LT少很多epoll的系统调用，因此效率高。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况。<br><b>总结：</b><br>　　当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait干了件事，就是检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。所以，非ET的句柄，只要它上面还有事件，epoll_wait每次都会返回这个句柄。</p>
<h3 id="四。select、poll、epoll三组I-O复用函数比较"><a href="#四。select、poll、epoll三组I-O复用函数比较" class="headerlink" title="四。select、poll、epoll三组I/O复用函数比较"></a>四。select、poll、epoll三组I/O复用函数比较</h3><table><thead><tr><th width="16%," style="text-align:center">系统调用</th><th width="28%," style="text-align:center">select</th><th width="28%," style="text-align:center">poll</th><th width="28%," style="text-align:center">epoll</th></tr></thead><tbody><tr><td style="text-align:center">事件管理</td><td style="text-align:center">用户通过3个参数分别传入感兴趣的可读、可写及异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件。所以用户每次调用select都要重置这3个参数。</td><td style="text-align:center">统一处理所有事件类型，只需一个事件集参数。用户通过pollfd.events传入感兴趣事件，内核通过修改polled.revents反馈其中就绪的事件。</td><td style="text-align:center">内核通过一个事件表直接管理用户感兴趣的所有事件，每次调用epoll_wait时，无须反复传入用户感兴趣的事件，epoll_wait系统调用的参数events仅用于反馈就绪的事件。</td></tr><tr><td style="text-align:center">索引就绪FD的时间复杂度</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(n)</td><td style="text-align:center">O(1)</td></tr><tr><td style="text-align:center">最大支持文件描述符</td><td style="text-align:center">一般有最大值限制</td><td style="text-align:center">65 535</td><td style="text-align:center">65 535</td></tr><tr><td style="text-align:center">工作模式</td><td style="text-align:center">LT</td><td style="text-align:center">LT</td><td style="text-align:center">支持ET模式</td></tr><tr><td style="text-align:center">内核实现和工作效率</td><td style="text-align:center">采用轮询方式来检测就绪事件</td><td style="text-align:center">采用轮询方式来检测就绪事件</td><td style="text-align:center">采用回调方式来检测就绪事件</td></tr></tbody></table>

<p>参考：<br><a href="http://www.cppblog.com/Khan/archive/2008/04/02/46013.html" target="_blank" rel="noopener">http://www.cppblog.com/Khan/archive/2008/04/02/46013.html</a><br><a href="http://www.cnblogs.com/charlesblc/p/6242479.html" target="_blank" rel="noopener">http://www.cnblogs.com/charlesblc/p/6242479.html</a><br><a href="http://www.cnblogs.com/charlesblc/p/5538363.html" target="_blank" rel="noopener">http://www.cnblogs.com/charlesblc/p/5538363.html</a><br><a href="http://blog.csdn.net/wangxmin2005/article/details/7587525" target="_blank" rel="noopener">http://blog.csdn.net/wangxmin2005/article/details/7587525</a></p>
</div><script type="text/javascript" src="/js/share.js?v=1.0.0" async></script><a data-url="http://huaixuzhi.github.io/2018/01/05/IO-multiplexing/" data-id="cjf3qpsub0002qgw2o2x3imlu" class="article-share-link">分享到</a><div class="tags"><a href="/tags/基础知识/">基础知识</a><a href="/tags/面试/">面试</a></div><div class="post-nav"><a href="/2018/01/18/gdb-manual/" class="pre">GDB常用命令</a><a href="/2018/01/05/my-memcpy-realization/" class="next">memcpy函数实现及其优化</a></div><div id="uyan_frame"><script src="http://v2.uyan.cc/code/uyan.js?uid='2128901## Your uyan_id. e.g. 1234567'"></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://huaixuzhi.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Flask/">Flask</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/GO语言/">GO语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/杂谈/">杂谈</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/架构/">架构</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/流媒体/">流媒体</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/测试/">测试</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/读书笔记/" style="font-size: 15px;">读书笔记</a> <a href="/tags/测试/" style="font-size: 15px;">测试</a> <a href="/tags/基础知识/" style="font-size: 15px;">基础知识</a> <a href="/tags/面试/" style="font-size: 15px;">面试</a> <a href="/tags/WEB开发/" style="font-size: 15px;">WEB开发</a> <a href="/tags/架构设计/" style="font-size: 15px;">架构设计</a> <a href="/tags/架构/" style="font-size: 15px;">架构</a> <a href="/tags/ruby/" style="font-size: 15px;">ruby</a> <a href="/tags/流媒体/" style="font-size: 15px;">流媒体</a> <a href="/tags/音视频/" style="font-size: 15px;">音视频</a> <a href="/tags/C语言/" style="font-size: 15px;">C语言</a> <a href="/tags/代码优化/" style="font-size: 15px;">代码优化</a> <a href="/tags/GO语言/" style="font-size: 15px;">GO语言</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/go-xml-to-json/">GO XML转JSON</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/go-struct-tag/">GO语言struct成员变量标签tag</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/13/go-underline-description/">GO语言下划线的作用</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/31/tcp-limit/">TCP单机连接数限制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/31/fd-limit/">Linux打开文件句柄限制</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/31/my-assert/">设计并使用断言</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/25/streaming-architecture/">直播平台架构案例</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/24/network-basic-01/">阻塞非阻塞与同步异步</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/18/gdb-manual/">GDB常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/05/IO-multiplexing/">I/O复用函数比较(select/poll/epoll)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://coolshell.cn/" title="CoolShell" target="_blank">CoolShell</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">纸上得来.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/huaixuzhi"> huaixz.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=1.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>